<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"controllers_affiliates_affiliates.controller.js.html":{"id":"controllers_affiliates_affiliates.controller.js.html","title":"Source: controllers/affiliates/affiliates.controller.js","body":" Shingo Affiliate Portal Classes AffiliatesControllerAffiliatesServiceAuthControllerAuthServiceBaseControllerCacheServiceFacilitatorsControllerFacilitatorsServiceSalesforceServiceUserServiceWorkshopsControllerWorkshopsService Source: controllers/affiliates/affiliates.controller.js &quot;use strict&quot;; var __decorate = (this &amp;&amp; this.__decorate) || function (decorators, target, key, desc) { var c = arguments.length, r = c &lt; 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d; if (typeof Reflect === &quot;object&quot; &amp;&amp; typeof Reflect.decorate === &quot;function&quot;) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i &gt;= 0; i--) if (d = decorators[i]) r = (c &lt; 3 ? d(r) : c &gt; 3 ? d(target, key, r) : d(target, key)) || r; return c &gt; 3 &amp;&amp; r &amp;&amp; Object.defineProperty(target, key, r), r; }; var __metadata = (this &amp;&amp; this.__metadata) || function (k, v) { if (typeof Reflect === &quot;object&quot; &amp;&amp; typeof Reflect.metadata === &quot;function&quot;) return Reflect.metadata(k, v); }; var __param = (this &amp;&amp; this.__param) || function (paramIndex, decorator) { return function (target, key) { decorator(target, key, paramIndex); } }; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const common_1 = require(&quot;@nestjs/common&quot;); const components_1 = require(&quot;../../components&quot;); const base_controller_1 = require(&quot;../base.controller&quot;); const objKeyValidator_1 = require(&quot;../../validators/objKeyValidator&quot;); /** * @desc Controller of the REST API logic for Affiliates * * @export * @class AffiliatesController * @extends {BaseController} */ let AffiliatesController = class AffiliatesController extends base_controller_1.BaseController { constructor(affService) { super(); this.affService = affService; } ; /** * @desc &lt;h5&gt;GET: /affiliates&lt;/h5&gt; Calls {@link AffiliatesService#getAll} to get a list of affiliates * * @param {Query} isPublicQ - Query parameter &lt;code&gt;'isPublic'&lt;/code&gt;; Expected values &lt;code&gt;[ 'true', 'false' ]&lt;/code&gt;; Alias &lt;code&gt;headers['x-force-refesh']&lt;/code&gt;; Returns public affiliates * @param {Header} isPublicH - Header &lt;code&gt;'x-is-public'&lt;/code&gt;; Expected values &lt;code&gt;[ 'true', 'false' ]&lt;/code&gt;; Alias &lt;code&gt;query['isPublic']&lt;/code&gt;; Returns public affiliates * @param {Header} [refresh='false'] - Header &lt;code&gt;'x-force-refresh'&lt;/code&gt;; Expected values &lt;code&gt;[ 'true', 'false' ]&lt;/code&gt;; Forces cache refresh * @returns {Promise&lt;Response&gt;} * @memberof AffiliatesController */ readAll(res, isPublicQ, isPublicH, refresh = 'false') { return __awaiter(this, void 0, void 0, function* () { const isPublic = (isPublicQ === 'true' || isPublicH === 'true'); const forceRefresh = refresh === 'true'; try { const affiliates = yield this.affService.getAll(isPublic, forceRefresh); return res.status(common_1.HttpStatus.OK).json(affiliates); } catch (error) { return this.handleError(res, 'Error in AffiliatesController.readAll(): ', error); } }); } /** * @desc &lt;h5&gt;GET: /affiliates/describe&lt;/h5&gt; Calls {@link AffiliatesService#describe} to describe the Account Object * * @param {Header} [refresh='false'] - Header &lt;code&gt;'x-force-refresh'&lt;/code&gt;; Expected values &lt;code&gt;[ 'true', 'false' ]&lt;/code&gt;; Forces cache refresh * @returns {Promise&lt;Response&gt;} * @memberof AffiliatesController */ describe(res, refresh = 'false') { return __awaiter(this, void 0, void 0, function* () { try { const describeObject = yield this.affService.describe(refresh === 'true'); return res.status(common_1.HttpStatus.OK).json(describeObject); } catch (error) { return this.handleError(res, 'Error in AffiliatesController.describe(): ', error); } }); } /** * @desc &lt;h5&gt;GET: /affiliates/search&lt;/h5&gt; Calls {@link AffiliatesService#search}. Returns an array of affiliates that match search criteria * * @param {Header} search - Header &lt;code&gt;'x-search'&lt;/code&gt;. SOSL search expression (i.e. '*Test*'). * @param {Header} retrieve - Header &lt;code&gt;'x-retrieve'&lt;/code&gt;. A comma seperated list of the Account fields to retrieve (i.e. 'Id, Name') * @param {Header} [refresh='false'] - Header &lt;code&gt;'x-force-refresh'&lt;/code&gt;; Expected values &lt;code&gt;[ 'true', 'false' ]&lt;/code&gt;; Forces cache refresh * @returns {Promise&lt;Response&gt;} * @memberof AffiliatesController */ search(res, search, retrieve, refresh = 'false') { return __awaiter(this, void 0, void 0, function* () { // Check for required fields if (!search || !retrieve) return this.handleError(res, 'Error in AffiliatesController.search(): ', { error: 'MISSING_PARAMETERS', params: (!search &amp;&amp; !retrieve ? ['search', 'retrieve '] : !search ? ['search'] : ['retrieve']) }, common_1.HttpStatus.BAD_REQUEST); try { const affiliates = yield this.affService.search(search, retrieve, refresh === 'true'); return res.status(common_1.HttpStatus.OK).json(affiliates); } catch (error) { return this.handleError(res, 'Error in AffiliatesController.search(): ', error); } }); } /** * @desc &lt;h5&gt;GET: /affiliates/&lt;em&gt;:id&lt;/em&gt;&lt;/h5&gt; Calls {@link AffiliatesService#get} to retrieve a specific affiliate * * @param {SalesforceId} id - Account id. match &lt;code&gt;/[\\w\\d]{15,17}/&lt;/code&gt; * @returns {Promise&lt;Response&gt;} * @memberof AffiliatesController */ read(res, id) { return __awaiter(this, void 0, void 0, function* () { if (!id.match(/[\\w\\d]{15,17}/)) return this.handleError(res, 'Error in AffiliatesController.read(): ', { error: 'INVALID_SF_ID', message: `${id} is not a valid Salesforce ID.` }, common_1.HttpStatus.BAD_REQUEST); try { const affiliate = yield this.affService.get(id); return res.status(common_1.HttpStatus.OK).json(affiliate); } catch (error) { return this.handleError(res, 'Error in AffiliatesController.read(): ', error); } }); } /** * @desc &lt;h5&gt;POST: /affiliates&lt;/h5&gt; Calls {@link AffiliatesService#create} to create a new Affiliate * * @param {Body} body - Required fields &lt;code&gt;[ &quot;Name&quot; ]&lt;/code&gt; * @returns {Promise&lt;Response&gt;} * @memberof AffiliatesController */ create(res, body) { return __awaiter(this, void 0, void 0, function* () { const required = objKeyValidator_1.checkRequired(body, ['Name']); if (!required.valid) this.handleError(res, 'Error in AffiliatesController.create(): ', { error: 'MISSING_FIELDS', fields: required.missing }, common_1.HttpStatus.BAD_REQUEST); try { const sfSuccess = yield this.affService.create(body); return res.status(common_1.HttpStatus.CREATED).json(sfSuccess); } catch (error) { return this.handleError(res, 'Error in AffiliatesController.create(): ', error); } }); } /** * @desc &lt;h5&gt;POST: /affiliates/&lt;em&gt;:id&lt;/em&gt;/map&lt;/h5&gt; Calls {@link AffiliatesService#map} to create permissions for a Licensed Affiliate Account * * @param {SalesforceId} id - Account id. match &lt;code&gt;/[\\w\\d]{15,17}/&lt;/code&gt; * @returns {Promise&lt;Response&gt;} * @memberof AffiliatesController */ map(res, id) { return __awaiter(this, void 0, void 0, function* () { if (!id.match(/[\\w\\d]{15,17}/)) return this.handleError(res, 'Error in AffiliatesController.read(): ', { error: 'INVALID_SF_ID', message: `${id} is not a valid Salesforce ID.` }, common_1.HttpStatus.BAD_REQUEST); try { yield this.affService.map(id); return res.status(common_1.HttpStatus.OK).json({ mapped: true }); } catch (error) { return this.handleError(res, 'Error in AffiliatesController.map(): ', error); } }); } /** * @desc &lt;h5&gt;PUT: /affiliates/&lt;em&gt;:id&lt;/em&gt;&lt;/h5&gt; Calls {@link AffiliatesService#update} to update an Affiliate * * @param {Body} body - Required fields &lt;code&gt;[ &quot;Id&quot; ]&lt;/code&gt; * @param {SalesforceId} id - Account id. match &lt;code&gt;/[\\w\\d]{15,17}/&lt;/code&gt; * @returns {Promise&lt;Response&gt;} * @memberof AffiliatesController */ update(res, body, id) { return __awaiter(this, void 0, void 0, function* () { if (!id.match(/[\\w\\d]{15,17}/) || id !== body.Id) return this.handleError(res, 'Error in AffiliatesController.update(): ', { error: 'INVALID_SF_ID', message: `${id} is not a valid Salesforce ID.` }, common_1.HttpStatus.BAD_REQUEST); let required = objKeyValidator_1.checkRequired(body, ['Id']); if (!required.valid) return this.handleError(res, 'Error in AffiliatesController.update(): ', { error: &quot;MISSING_FIELDS&quot;, fields: required.missing }, common_1.HttpStatus.BAD_REQUEST); try { const result = yield this.affService.update(body); return res.status(common_1.HttpStatus.OK).json(result); } catch (error) { return this.handleError(res, 'Error in AffiliatesController.update(): ', error); } }); } /** * @desc &lt;h5&gt;DELETE: /affiliates/&lt;em&gt;:id&lt;/em&gt;&lt;/h5&gt; Calls {@link AffiliatesService#delete} to delete an Affiliate * * @param {SalesforceId} id - Account id. match &lt;code&gt;/[\\w\\d]{15,17}/&lt;/code&gt; * @returns {Promise&lt;Response&gt;} * @memberof AffiliatesController */ delete(res, id) { return __awaiter(this, void 0, void 0, function* () { if (!id.match(/[\\w\\d]{15,17}/)) return this.handleError(res, 'Error in AffiliatesController.delete(): ', { error: 'INVALID_SF_ID', message: `${id} is not a valid Salesforce ID.` }, common_1.HttpStatus.BAD_REQUEST); try { const result = yield this.affService.delete(id); return res.status(common_1.HttpStatus.OK).json(result); } catch (error) { return this.handleError(res, 'Error in AffiliatesController.delete(): ', error); } }); } }; __decorate([ common_1.Get(), __param(0, common_1.Response()), __param(1, common_1.Query('isPublic')), __param(2, common_1.Headers('x-is-public')), __param(3, common_1.Headers('x-force-refresh')), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object, Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], AffiliatesController.prototype, &quot;readAll&quot;, null); __decorate([ common_1.Get('/describe'), __param(0, common_1.Response()), __param(1, common_1.Headers('x-force-refresh')), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], AffiliatesController.prototype, &quot;describe&quot;, null); __decorate([ common_1.Get('/search'), __param(0, common_1.Response()), __param(1, common_1.Headers('x-search')), __param(2, common_1.Headers('x-retrieve')), __param(3, common_1.Headers('x-force-refresh')), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object, Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], AffiliatesController.prototype, &quot;search&quot;, null); __decorate([ common_1.Get(':id'), __param(0, common_1.Response()), __param(1, common_1.Param('id')), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], AffiliatesController.prototype, &quot;read&quot;, null); __decorate([ common_1.Post(), __param(0, common_1.Response()), __param(1, common_1.Body()), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], AffiliatesController.prototype, &quot;create&quot;, null); __decorate([ common_1.Post(':id/map'), __param(0, common_1.Response()), __param(1, common_1.Param('id')), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], AffiliatesController.prototype, &quot;map&quot;, null); __decorate([ common_1.Put(':id'), __param(0, common_1.Response()), __param(1, common_1.Body()), __param(2, common_1.Param('id')), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], AffiliatesController.prototype, &quot;update&quot;, null); __decorate([ common_1.Delete(':id'), __param(0, common_1.Response()), __param(1, common_1.Param('id')), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], AffiliatesController.prototype, &quot;delete&quot;, null); AffiliatesController = __decorate([ common_1.Controller('affiliates'), __metadata(&quot;design:paramtypes&quot;, [components_1.AffiliatesService]) ], AffiliatesController); exports.AffiliatesController = AffiliatesController; × Search results Close "},"controllers_base.controller.js.html":{"id":"controllers_base.controller.js.html","title":"Source: controllers/base.controller.js","body":" Shingo Affiliate Portal Classes AffiliatesControllerAffiliatesServiceAuthControllerAuthServiceBaseControllerCacheServiceFacilitatorsControllerFacilitatorsServiceSalesforceServiceUserServiceWorkshopsControllerWorkshopsService Source: controllers/base.controller.js &quot;use strict&quot;; var __decorate = (this &amp;&amp; this.__decorate) || function (decorators, target, key, desc) { var c = arguments.length, r = c &lt; 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d; if (typeof Reflect === &quot;object&quot; &amp;&amp; typeof Reflect.decorate === &quot;function&quot;) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i &gt;= 0; i--) if (d = decorators[i]) r = (c &lt; 3 ? d(r) : c &gt; 3 ? d(target, key, r) : d(target, key)) || r; return c &gt; 3 &amp;&amp; r &amp;&amp; Object.defineProperty(target, key, r), r; }; var __metadata = (this &amp;&amp; this.__metadata) || function (k, v) { if (typeof Reflect === &quot;object&quot; &amp;&amp; typeof Reflect.metadata === &quot;function&quot;) return Reflect.metadata(k, v); }; var __param = (this &amp;&amp; this.__param) || function (paramIndex, decorator) { return function (target, key) { decorator(target, key, paramIndex); } }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const common_1 = require(&quot;@nestjs/common&quot;); const components_1 = require(&quot;../components&quot;); /** * @desc The base controller class contains methods shared between multiple routes * * @export * @class BaseController */ class BaseController { /** * @desc A helper function to return an error response to the client. * * @protected * @param {Response} res - The express response from the calling route * @param {string} message - Log message * @param {*} error - An error object to be logged and returned as JSON * @param {HttpStatus} [errorCode=HttpStatus.INTERNAL_SERVER_ERROR] - HttpStatus CODE * @returns Response body is a JSON object with the error * @memberof BaseController */ handleError(res, message, error, errorCode = common_1.HttpStatus.INTERNAL_SERVER_ERROR) { if (error.metadata) error = components_1.SalesforceService.parseRPCErrorMeta(error); console.error(message, error); return res.status(errorCode).json({ error }); } } __decorate([ __param(0, common_1.Response()), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, String, Object, Number]), __metadata(&quot;design:returntype&quot;, void 0) ], BaseController.prototype, &quot;handleError&quot;, null); exports.BaseController = BaseController; × Search results Close "},"components_affiliates_affiliates.component.js.html":{"id":"components_affiliates_affiliates.component.js.html","title":"Source: components/affiliates/affiliates.component.js","body":" Shingo Affiliate Portal Classes AffiliatesControllerAffiliatesServiceAuthControllerAuthServiceBaseControllerCacheServiceFacilitatorsControllerFacilitatorsServiceSalesforceServiceUserServiceWorkshopsControllerWorkshopsService Source: components/affiliates/affiliates.component.js &quot;use strict&quot;; var __decorate = (this &amp;&amp; this.__decorate) || function (decorators, target, key, desc) { var c = arguments.length, r = c &lt; 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d; if (typeof Reflect === &quot;object&quot; &amp;&amp; typeof Reflect.decorate === &quot;function&quot;) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i &gt;= 0; i--) if (d = decorators[i]) r = (c &lt; 3 ? d(r) : c &gt; 3 ? d(target, key, r) : d(target, key)) || r; return c &gt; 3 &amp;&amp; r &amp;&amp; Object.defineProperty(target, key, r), r; }; var __metadata = (this &amp;&amp; this.__metadata) || function (k, v) { if (typeof Reflect === &quot;object&quot; &amp;&amp; typeof Reflect.metadata === &quot;function&quot;) return Reflect.metadata(k, v); }; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const common_1 = require(&quot;@nestjs/common&quot;); const _1 = require(&quot;../&quot;); /** * @desc A service to provide functions for working with Affiliates * * @export * @class AffiliatesService */ let AffiliatesService = class AffiliatesService { constructor() { this.sfService = new _1.SalesforceService(); this.authService = new _1.AuthService(); this.cache = new _1.CacheService(); } ; /** * @desc Get all AFfiliates (minus McKinsey if &lt;code&gt;isPublic&lt;/code&gt;). Queries the following fields:&lt;br&gt;&lt;br&gt; * &lt;code&gt;[&lt;br&gt; * &amp;emsp;&quot;Id&quot;,&lt;br&gt; * &amp;emsp;&quot;Name&quot;,&lt;br&gt; * &amp;emsp;&quot;Summary__c&quot;,&lt;br&gt; * &amp;emsp;&quot;Logo__c&quot;,&lt;br&gt; * &amp;emsp;&quot;Page_Path__c&quot;,&lt;br&gt; * &amp;emsp;&quot;Website&quot;,&lt;br&gt; * &amp;emsp;&quot;Languages__c&quot;&lt;br&gt; * ]&lt;/code&gt; * * @param {boolean} [isPublic=false] - Filter out private Affiliates * @param {boolean} [refresh=false] - Force the refresh of the cache * @returns {Promise&lt;Affiliate[]&gt;} * @memberof AffiliatesService */ getAll(isPublic = false, refresh = false) { return __awaiter(this, void 0, void 0, function* () { const query = { action: &quot;SELECT&quot;, fields: [ &quot;Id&quot;, &quot;Name&quot;, &quot;Summary__c&quot;, &quot;Logo__c&quot;, &quot;Page_Path__c&quot;, &quot;Website&quot;, &quot;Languages__c&quot; ], table: &quot;Account&quot;, clauses: &quot;RecordType.Name='Licensed Affiliate'&quot; }; if (!isPublic) query.clauses += &quot; AND (NOT Name LIKE 'McKinsey%')&quot;; if (!this.cache.isCached(query) || refresh) { const affiliates = (yield this.sfService.query(query)).records; if (isPublic) this.cache.cache(query, affiliates); return Promise.resolve(affiliates); } else { return Promise.resolve(this.cache.getCache(query)); } }); } /** * @desc Get the facilitator with the id passed at the parameter :id. The following fields are returned:&lt;br&gt;&lt;br&gt; * &lt;code&gt;[&lt;br&gt; * TODO: Add fields that are returned&lt;br&gt; * ]&lt;/code&gt; * * @param {string} id - Salesforce ID for an Account * @returns {Promise&lt;Affiliate&gt;} * @memberof AffiliatesService */ get(id) { return __awaiter(this, void 0, void 0, function* () { const affiliate = (yield this.sfService.retrieve({ object: 'Account', ids: [id] }))[0]; return Promise.resolve(affiliate); }); } /** * @desc Uses the Salesforce REST API to describe the Account object. See the Salesforce documentation for more about 'describe' * * @param {boolean} [refresh=false] - Force the refresh of the cache * @returns {Promise&lt;any&gt;} * @memberof AffiliatesService */ describe(refresh = false) { return __awaiter(this, void 0, void 0, function* () { // Set the key for the cache const key = 'describeAccounts'; // If no cached result, use the shingo-sf-api to get the result if (!this.cache.isCached(key) || refresh) { const describeObject = yield this.sfService.describe('Account'); // Cache describe this.cache.cache(key, describeObject); return Promise.resolve(describeObject); } else { return Promise.resolve(this.cache.getCache(key)); } }); } /** * @desc Executes a SOSL query to search for text on Accounts of record type Licensed Affiliate. Example response body:&lt;br&gt;&lt;br&gt; * &lt;code&gt;[&lt;br&gt; * &amp;emsp;{&lt;br&gt; * &amp;emsp;&amp;emsp;&quot;Id&quot;: &quot;003g000001VvwEZAAZ&quot;,&lt;br&gt; * &amp;emsp;&amp;emsp;&quot;Name&quot;: &quot;Test One&quot;,&lt;br&gt; * &amp;emsp;},&lt;br&gt; * &amp;emsp;{&lt;br&gt; * &amp;emsp;&amp;emsp;&quot;Id&quot;: &quot;003g000001VvwEZABA&quot;,&lt;br&gt; * &amp;emsp;&amp;emsp;&quot;Name&quot;: &quot;Test Two&quot;,&lt;br&gt; * &amp;emsp;},&lt;br&gt; * &amp;emsp;{&lt;br&gt; * &amp;emsp;&amp;emsp;&quot;Id&quot;: &quot;003g000001VvwEZABB&quot;,&lt;br&gt; * &amp;emsp;&amp;emsp;&quot;Name&quot;: &quot;Test Three&quot;,&lt;br&gt; * &amp;emsp;},&lt;br&gt; * ]&lt;/code&gt; * * @param {Header} search - Header 'x-search'. SOSL search expression (i.e. '*Test*'). * @param {Header} retrieve - Header 'x-retrieve'. A comma seperated list of the Account fields to retrieve (i.e. 'Id, Name') * @param {boolean} [refresh=false] - Force the refresh of the cache * @returns {Promise&lt;Affiliate[]&gt;} * @memberof AffiliatesService */ search(search, retrieve, refresh = false) { return __awaiter(this, void 0, void 0, function* () { if (!retrieve.includes('RecordType.Name')) retrieve += ', RecordType.Name'; // Generate the data parameter for the RPC call const data = { search: `{${search}}`, retrieve: `Account(${retrieve})` }; // If no cached result, use the shingo-sf-api to get result if (!this.cache.isCached(data) || refresh) { let affiliates = (yield this.sfService.search(data)).searchRecords; affiliates = affiliates.filter(aff =&gt; { return aff.RecordType.Name === 'Licensed Affiliate'; }); // Cache results this.cache.cache(data, affiliates); return Promise.resolve(affiliates); } else { return Promise.resolve(this.cache.getCache(data)); } }); } /** * @desc Creates a new Account of record type 'Licensed Affiliate' in Salesforce and corresponding permissions and roles. Returns the following:&lt;br&gt;&lt;br&gt; * &lt;code&gt;{&lt;br&gt; * &amp;emsp;&quot;id&quot;: SalesforceId,&lt;br&gt; * &amp;emsp;&quot;success&quot;: boolean,&lt;br&gt; * &amp;emsp;&quot;errors&quot;: []&lt;br&gt; * }&lt;/code&gt; * * @param {Affiliate} affiliate - Affiliate to create * @returns {Promise&lt;any&gt;} * @memberof AffiliatesService */ create(affiliate) { return __awaiter(this, void 0, void 0, function* () { affiliate.RecordTypeId = '012A0000000zpraIAA'; // Use the shingo-sf-api to create the new record const data = { object: 'Account', records: [{ contents: JSON.stringify(affiliate) }] }; const result = (yield this.sfService.create(data))[0]; yield this.map(result.id); return Promise.resolve(result); }); } /** * @desc Create the corresponding permissions and roles for the Affiliate in the Shingo Auth API. * * @param {string} id - Affiliate's Account Id * @returns {Promise&lt;any&gt;} * @memberof AffiliatesService */ map(id) { return __awaiter(this, void 0, void 0, function* () { const cm = yield this.authService.createRole({ name: `Course Manager -- ${id}`, service: 'affiliate-portal' }); for (const level of [0, 1, 2]) { const workshopPerm = yield this.authService.createPermission({ resource: `workshops -- ${id}`, level }); yield this.authService.grantPermissionToRole(workshopPerm.resource, 2, cm.id); const affiliatePerm = yield this.authService.createPermission({ resource: `affiliate -- ${id}`, level }); yield this.authService.grantPermissionToRole(affiliatePerm.resource, 1, cm.id); } return Promise.resolve(); }); } /** * @desc Updates an Affiliate's fields: Returns the following:&lt;br&gt;&lt;br&gt; * &lt;code&gt;{&lt;br&gt; * &amp;emsp;&quot;id&quot;: SalesforceId,&lt;br&gt; * &amp;emsp;&quot;success&quot;: boolean,&lt;br&gt; * &amp;emsp;&quot;errors&quot;: []&lt;br&gt; * }&lt;/code&gt; * * @param {Affiliate} affiliate - Affiliate's fields to update * @returns {Promise&lt;any&gt;} * @memberof AffiliatesService */ update(affiliate) { return __awaiter(this, void 0, void 0, function* () { // Use the shingo-sf-api to create the new record const data = { object: 'Account', records: [{ contents: JSON.stringify(affiliate) }] }; const result = (yield this.sfService.update(data))[0]; return Promise.resolve(result); }); } /** * @desc Deletes an Affiliate. Returns the following:&lt;br&gt;&lt;br&gt; * &lt;code&gt;{&lt;br&gt; * &amp;emsp;&quot;id&quot;: SalesforceId,&lt;br&gt; * &amp;emsp;&quot;success&quot;: boolean,&lt;br&gt; * &amp;emsp;&quot;errors&quot;: []&lt;br&gt; * }&lt;/code&gt; * * @param {string} id - Salesforce Id of the Account to delete * @returns {Promise&lt;any&gt;} * @memberof AffiliatesService */ delete(id) { return __awaiter(this, void 0, void 0, function* () { // Create the data parameter for the RPC call const data = { object: 'Account', ids: [id] }; const result = (yield this.sfService.delete(data))[0]; for (const level of [0, 1, 2]) { yield this.authService.deletePermission(`workshops -- ${id}`, level); yield this.authService.deletePermission(`affiliate -- ${id}`, level); } const cm = yield this.authService.getRole(`role.name='Course Manager -- ${id}'`); yield this.authService.deleteRole(cm); return Promise.resolve(result); }); } }; AffiliatesService = __decorate([ common_1.Component(), __metadata(&quot;design:paramtypes&quot;, []) ], AffiliatesService); exports.AffiliatesService = AffiliatesService; × Search results Close "},"controllers_auth_auth.controller.js.html":{"id":"controllers_auth_auth.controller.js.html","title":"Source: controllers/auth/auth.controller.js","body":" Shingo Affiliate Portal Classes AffiliatesControllerAffiliatesServiceAuthControllerAuthServiceBaseControllerCacheServiceFacilitatorsControllerFacilitatorsServiceSalesforceServiceUserServiceWorkshopsControllerWorkshopsService Source: controllers/auth/auth.controller.js &quot;use strict&quot;; var __decorate = (this &amp;&amp; this.__decorate) || function (decorators, target, key, desc) { var c = arguments.length, r = c &lt; 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d; if (typeof Reflect === &quot;object&quot; &amp;&amp; typeof Reflect.decorate === &quot;function&quot;) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i &gt;= 0; i--) if (d = decorators[i]) r = (c &lt; 3 ? d(r) : c &gt; 3 ? d(target, key, r) : d(target, key)) || r; return c &gt; 3 &amp;&amp; r &amp;&amp; Object.defineProperty(target, key, r), r; }; var __metadata = (this &amp;&amp; this.__metadata) || function (k, v) { if (typeof Reflect === &quot;object&quot; &amp;&amp; typeof Reflect.metadata === &quot;function&quot;) return Reflect.metadata(k, v); }; var __param = (this &amp;&amp; this.__param) || function (paramIndex, decorator) { return function (target, key) { decorator(target, key, paramIndex); } }; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const common_1 = require(&quot;@nestjs/common&quot;); const components_1 = require(&quot;../../components&quot;); const base_controller_1 = require(&quot;../base.controller&quot;); const _ = require(&quot;lodash&quot;); /** * @desc Provides the controller of the Auth REST logic * * @export * @class AuthController * @extends {BaseController} */ let AuthController = class AuthController extends base_controller_1.BaseController { constructor(sfService, authService) { super(); this.sfService = sfService; this.authService = authService; } ; /** * @desc &lt;h5&gt;POST: /auth/login&lt;/h5&gt; Calls {@link AuthService#login} and {@link SalesforceService#query} to login a user * * @param {any} body - Required fields: &lt;code&gt;[ 'email', 'password' ]&lt;/code&gt; * @returns {Promise&lt;Response&gt;} Response body is an object with the user's JWT * @memberof AuthController */ login(req, res, body) { return __awaiter(this, void 0, void 0, function* () { if (!body.email || !body.password) return this.handleError(res, 'Error in AuthController.login(): ', { error: &quot;MISSING_FIELDS&quot; }, common_1.HttpStatus.BAD_REQUEST); try { const user = yield this.authService.login({ email: body.email, password: body.password }); if (user === undefined) return this.handleError(res, 'Error in AuthController.login(): ', { error: 'INVALID_LOGIN' }, common_1.HttpStatus.FORBIDDEN); if (!user.services.includes('affiliate-portal')) return this.handleError(res, 'Error in AuthController.login(): ', { error: 'NOT_REGISTERED' }, common_1.HttpStatus.NOT_FOUND); const query = { action: 'SELECT', fields: [ 'Id', 'Name', 'FirstName', 'LastName', 'AccountId', 'Email' ], table: 'Contact', clauses: `Email='${body.email}' AND RecordType.Name='Affiliate Instructor'` }; const contact = (yield this.sfService.query(query)).records[0]; req.session.user = _.omit(user, ['password']); req.session.user.contact = contact; req.session.affiliate = contact['AccountId']; return res.status(common_1.HttpStatus.OK).json({ jwt: user.jwt }); } catch (error) { return this.handleError(res, 'Error in AuthController.login(): ', error); } }); } /** * &lt;h5&gt;GET: /auth/valid&lt;/h5&gt; Protected by isValid middleware. Only get called if the value of x-jwt corresponds to a valid user * * @returns {Promise&lt;Response&gt;} * @memberof AuthController */ async(res) { return res.status(common_1.HttpStatus.OK).json(); } /** * @desc &lt;h5&gt;GET: /auth/logout&lt;/h5&gt; Calls {@link AuthService#updateUser} to set the user's JWT to '' and removes the user from the session * * @returns {Promise&lt;Response&gt;} * @memberof AuthController */ logout(req, res) { return __awaiter(this, void 0, void 0, function* () { if (!req.session.user) return this.handleError(res, 'Error in AuthController.logout(): ', { error: 'NO_LOGIN_FOUND' }); try { req.session.user.jwt = ''; yield this.authService.updateUser(_.omit(req.session.user, ['contact'])); req.session.user = null; return res.status(common_1.HttpStatus.OK).json({ message: &quot;LOGOUT_SUCCESS&quot; }); } catch (error) { return this.handleError(res, 'Error in AuthController.logout(): ', error); } }); } }; __decorate([ common_1.Post('login'), __param(0, common_1.Request()), __param(1, common_1.Response()), __param(2, common_1.Body()), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], AuthController.prototype, &quot;login&quot;, null); __decorate([ common_1.Get('valid'), __param(0, common_1.Response()), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object]), __metadata(&quot;design:returntype&quot;, Promise) ], AuthController.prototype, &quot;async&quot;, null); __decorate([ common_1.Get('logout'), __param(0, common_1.Request()), __param(1, common_1.Response()), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], AuthController.prototype, &quot;logout&quot;, null); AuthController = __decorate([ common_1.Controller('auth'), __metadata(&quot;design:paramtypes&quot;, [components_1.SalesforceService, components_1.AuthService]) ], AuthController); exports.AuthController = AuthController; × Search results Close "},"components_auth_auth.component.js.html":{"id":"components_auth_auth.component.js.html","title":"Source: components/auth/auth.component.js","body":" Shingo Affiliate Portal Classes AffiliatesControllerAffiliatesServiceAuthControllerAuthServiceBaseControllerCacheServiceFacilitatorsControllerFacilitatorsServiceSalesforceServiceUserServiceWorkshopsControllerWorkshopsService Source: components/auth/auth.component.js &quot;use strict&quot;; var __decorate = (this &amp;&amp; this.__decorate) || function (decorators, target, key, desc) { var c = arguments.length, r = c &lt; 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d; if (typeof Reflect === &quot;object&quot; &amp;&amp; typeof Reflect.decorate === &quot;function&quot;) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i &gt;= 0; i--) if (d = decorators[i]) r = (c &lt; 3 ? d(r) : c &gt; 3 ? d(target, key, r) : d(target, key)) || r; return c &gt; 3 &amp;&amp; r &amp;&amp; Object.defineProperty(target, key, r), r; }; var __metadata = (this &amp;&amp; this.__metadata) || function (k, v) { if (typeof Reflect === &quot;object&quot; &amp;&amp; typeof Reflect.metadata === &quot;function&quot;) return Reflect.metadata(k, v); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const common_1 = require(&quot;@nestjs/common&quot;); const grpc = require(&quot;grpc&quot;); const path = require(&quot;path&quot;); const bluebird = require(&quot;bluebird&quot;); const authservices = grpc.load(path.join(__dirname, '../../../proto/auth_services.proto')).authservices; /** * @desc A service to abastract the Shingo Auth Microservice client * * @export * @class AuthService */ let AuthService = class AuthService { constructor() { this.client = bluebird.promisifyAll(this.getClient()); } /** * @desc Method to instantiate a RPC Client from the auth_services.proto * * @private * @returns Returns a RPC Client to be used in consuming the Shingo Auth Microservice * @memberof AuthService */ getClient() { return new authservices.AuthServices(`${process.env.AUTH_API}:80`, grpc.credentials.createInsecure()); } getUsers(clause) { return this.client.readUserAsync({ clause }); } getUser(clause) { return this.client.readOneUserAsync({ clause }); } createUser(user) { return this.client.createUserAsync(user); } updateUser(user) { return this.client.updateUserAsync(user); } deleteUser(user) { return this.client.deleteUserAsync(user); } addRoleToUser(set) { return this.client.addRoleToUserAsync(set); } removeRoleFromUser(set) { return this.client.removeRoleFromUserAsync(set); } getPermissions(clause) { return this.client.readPermissionAsync({ clause }); } createPermission(permission) { return this.client.createPermissionAsync(permission); } updatePermission(permission) { return this.client.updatePermissionAsync(permission); } getPermission(clause) { return this.client.readOnePermissionAsync({ clause }); } deletePermission(resource, level) { return this.client.deletePermissionAsync({ resource, level }); } getRoles(clause) { return this.client.readRoleAsync({ clause }); } getRole(clause) { return this.client.readOneRoleAsync({ clause }); } createRole(role) { return this.client.createRoleAsync(role); } updateRole(role) { return this.client.updateRoleAsync(role); } deleteRole(role) { return this.client.deleteRoleAsync(role); } grantPermissionToUser(resource, level, userId) { return this.client.grantPermissionToUserAsync({ resource, level, accessorId: userId }); } grantPermissionToRole(resource, level, roleId) { return this.client.grantPermissionToRoleAsync({ resource, level, accessorId: roleId }); } revokePermissionFromUser(resource, level, userId) { return this.client.revokePermissionFromUserAsync({ resource, level, accessorId: userId }); } revokePermissionFromRole(resource, level, roleId) { return this.client.revokePermissionFromRoleAsync({ resource, level, accessorId: roleId }); } login(creds) { return this.client.loginAsync(creds); } isValid(token) { return this.client.isValidAsync({ token }); } canAccess(resource, level, jwt) { return this.client.canAccessAsync({ resource, level, jwt }); } /** * @desc Utility method to assist in parsing gRPC error metadata. Returns a JSON object from the parsed error data. If no JSON object can be parsed, the method attempts to return the 'error-bin' from the meta-data as a string. If that fails the method returns the error passed to it. * * @param {gRPCError} error - The error to be parsed * @returns {object} The parsed error, 'error-bin'.toString(), or passed in error * @memberof AuthService */ parseRPCErrorMeta(error) { try { let err = JSON.parse(error.metadata.get('error-bin').toString()); return err; } catch (caught) { console.error('Couldn\\'t parse RPC Error;', { error, caught }); if (error.metadata.get('error-bin')) return error.metadata.get('error-bin').toString(); else return error; } } }; AuthService = __decorate([ common_1.Component(), __metadata(&quot;design:paramtypes&quot;, []) ], AuthService); exports.AuthService = AuthService; × Search results Close "},"components_cache_cache.component.js.html":{"id":"components_cache_cache.component.js.html","title":"Source: components/cache/cache.component.js","body":" Shingo Affiliate Portal Classes AffiliatesControllerAffiliatesServiceAuthControllerAuthServiceBaseControllerCacheServiceFacilitatorsControllerFacilitatorsServiceSalesforceServiceUserServiceWorkshopsControllerWorkshopsService Source: components/cache/cache.component.js &quot;use strict&quot;; var __decorate = (this &amp;&amp; this.__decorate) || function (decorators, target, key, desc) { var c = arguments.length, r = c &lt; 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d; if (typeof Reflect === &quot;object&quot; &amp;&amp; typeof Reflect.decorate === &quot;function&quot;) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i &gt;= 0; i--) if (d = decorators[i]) r = (c &lt; 3 ? d(r) : c &gt; 3 ? d(target, key, r) : d(target, key)) || r; return c &gt; 3 &amp;&amp; r &amp;&amp; Object.defineProperty(target, key, r), r; }; var __metadata = (this &amp;&amp; this.__metadata) || function (k, v) { if (typeof Reflect === &quot;object&quot; &amp;&amp; typeof Reflect.metadata === &quot;function&quot;) return Reflect.metadata(k, v); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const common_1 = require(&quot;@nestjs/common&quot;); const NodeCache = require(&quot;node-cache&quot;); const hash = require(&quot;object-hash&quot;); /** * @desc A service that provides an in-memory cache * * @export * @class CacheService */ let CacheService = class CacheService { constructor() { this.theCache = new NodeCache({ stdTTL: 1800, checkperiod: 900 }); } /** * @desc Helper function to hash an object to a key * * @private * @param {object} obj * @returns {string} * @memberof CacheService */ getKey(obj) { return hash(obj); } /** * @desc Get the cached result for the give key * * @param {(object | string)} obj * @returns The cached result. 'undefined' if key is not found. * @memberof CacheService */ getCache(obj) { let key = obj; if (typeof obj !== 'string') key = this.getKey(obj); return this.theCache.get(key); } /** * @desc Checks if cache contains key * * @param {(object | string)} obj * @returns {boolean} * @memberof CacheService */ isCached(obj) { let key = obj; if (typeof obj !== 'string') key = this.getKey(obj); return this.theCache.get(key) !== undefined; } /** * @desc Caches the value based on the resulting key. Logs error if not successfully. * * @param {(object | string)} obj * @param {*} value * @memberof CacheService */ cache(obj, value) { let key = obj; if (typeof obj !== 'string') key = this.getKey(obj); if (!value) return; const success = this.theCache.set(key, value); if (!success) console.error(&quot;Response could not be cached!&quot;); } }; CacheService = __decorate([ common_1.Component(), __metadata(&quot;design:paramtypes&quot;, []) ], CacheService); exports.CacheService = CacheService; × Search results Close "},"controllers_facilitators_facilitators.controller.js.html":{"id":"controllers_facilitators_facilitators.controller.js.html","title":"Source: controllers/facilitators/facilitators.controller.js","body":" Shingo Affiliate Portal Classes AffiliatesControllerAffiliatesServiceAuthControllerAuthServiceBaseControllerCacheServiceFacilitatorsControllerFacilitatorsServiceSalesforceServiceUserServiceWorkshopsControllerWorkshopsService Source: controllers/facilitators/facilitators.controller.js &quot;use strict&quot;; var __decorate = (this &amp;&amp; this.__decorate) || function (decorators, target, key, desc) { var c = arguments.length, r = c &lt; 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d; if (typeof Reflect === &quot;object&quot; &amp;&amp; typeof Reflect.decorate === &quot;function&quot;) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i &gt;= 0; i--) if (d = decorators[i]) r = (c &lt; 3 ? d(r) : c &gt; 3 ? d(target, key, r) : d(target, key)) || r; return c &gt; 3 &amp;&amp; r &amp;&amp; Object.defineProperty(target, key, r), r; }; var __metadata = (this &amp;&amp; this.__metadata) || function (k, v) { if (typeof Reflect === &quot;object&quot; &amp;&amp; typeof Reflect.metadata === &quot;function&quot;) return Reflect.metadata(k, v); }; var __param = (this &amp;&amp; this.__param) || function (paramIndex, decorator) { return function (target, key) { decorator(target, key, paramIndex); } }; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const common_1 = require(&quot;@nestjs/common&quot;); const components_1 = require(&quot;../../components&quot;); const base_controller_1 = require(&quot;../base.controller&quot;); const objKeyValidator_1 = require(&quot;../../validators/objKeyValidator&quot;); const _ = require(&quot;lodash&quot;); /** * @desc Controller of the REST API logic for Facilitators * * @export * @class FacilitatorsController * @extends {BaseController} */ let FacilitatorsController = class FacilitatorsController extends base_controller_1.BaseController { constructor(facilitatorsService) { super(); this.facilitatorsService = facilitatorsService; } ; /** * @desc &lt;h5&gt;GET: /facilitators&lt;/h5&gt; Call {@link FacilitatorsService#getAll} to get a list of facilitators for given &lt;code&gt;'x-affiliate' || req.session.affilaite&lt;/code&gt; * * @param {Header} [xAffiliate=''] - Header 'x-affiliate' Used by the 'Affiliate Manager' role to specify the affiliate to query facilitators for ('' queries all affiliates). * @param {Header} [refresh='false'] - Header &lt;code&gt;'x-force-refresh'&lt;/code&gt;; Expected values &lt;code&gt;[ 'true', 'false' ]&lt;/code&gt;; Forces cache refresh * @returns {Promise&lt;Response&gt;} Response body is JSON Array of objects of type &lt;code&gt;{&lt;em&gt;queried fields&lt;/em&gt;}&lt;/code&gt; * @memberof FacilitatorsController */ readAll(req, res, xAffiliate = '', refresh = 'false') { return __awaiter(this, void 0, void 0, function* () { let isAfMan = false; for (let role of req.session.user.roles) { if (role.name === 'Affiliate Manager') isAfMan = true; } if (!isAfMan &amp;&amp; !req.session.affilaite) return this.handleError(res, 'Error in FacilitatorsController.readAll(): ', { error: 'MISSING_FIELDS' }, common_1.HttpStatus.FORBIDDEN); try { const facilitators = yield this.facilitatorsService.getAll(req.session.user, refresh === 'true', (isAfMan ? xAffiliate : req.session.affilaite)); return res.status(common_1.HttpStatus.OK).json(facilitators); } catch (error) { return this.handleError(res, 'Error in FacilitatorsController.readAll(): ', error); } }); } /** * @desc &lt;h5&gt;GET: /facilitators/describe&lt;/h5&gt; Calls {@link FacilitatorsService#describe} to describe Contact * * @param {Header} [refresh='false'] - Header &lt;code&gt;'x-force-refresh'&lt;/code&gt;; Expected values &lt;code&gt;[ 'true', 'false' ]&lt;/code&gt;; Forces cache refresh * @returns {Promise&lt;Response&gt;} Response body is a JSON object with the describe result * @memberof FacilitatorsController */ describe(res, refresh = 'false') { return __awaiter(this, void 0, void 0, function* () { try { const describeObject = yield this.facilitatorsService.describe(refresh === 'true'); return res.status(common_1.HttpStatus.OK).json(describeObject); } catch (error) { return this.handleError(res, 'Error in FacilitatorsController.describe(): ', error); } }); } /** * @desc &lt;h5&gt;GET: /facilitators/search&lt;/h5&gt; Calls {@link FacilitatorsService#search} to search for facilitators * * * @param {Header} search - Header 'x-search'. SOSL search expression (i.e. '*Test*') * @param {Header} retrieve - Header 'x-retrieve'. A comma seperated list of the Contact fields to retrieve (i.e. 'Id, Name, Email') * @param {Header} [refresh='false'] - Header &lt;code&gt;'x-force-refresh'&lt;/code&gt;; Expected values &lt;code&gt;[ 'true', 'false' ]&lt;/code&gt;; Forces cache refresh * @returns {Promise&lt;Response&gt;} Response body is a JSON Array of objects of type {&lt;em&gt;retrieve fields&lt;/em&gt;} * @memberof FacilitatorsController */ search(req, res, search, retrieve, refresh = 'false') { return __awaiter(this, void 0, void 0, function* () { let isAfMan = false; for (let role of req.session.user.roles) { if (role.name === 'Affiliate Manager') isAfMan = true; } if (!isAfMan &amp;&amp; !req.session.affiliate) return this.handleError(res, 'Error in FacilitatorsController.search(): ', { error: 'MISSING_FIELDS' }, common_1.HttpStatus.BAD_REQUEST); // Check for required fields if (!search || !retrieve) return this.handleError(res, 'Error in FacilitatorsController.search(): ', { error: 'MISSING_FIELDS' }, common_1.HttpStatus.BAD_REQUEST); try { const searchRecords = yield this.facilitatorsService.search(search, retrieve, (isAfMan ? '' : req.session.affiliate), refresh === 'true'); return res.status(common_1.HttpStatus.OK).json(searchRecords); } catch (error) { return this.handleError(res, 'Error in FacilitatorsController.search(): ', error); } }); } /** * @desc &lt;h5&gt;GET: /facilitators/&lt;em&gt;:id&lt;/em&gt;&lt;/h5&gt; Calls {@link FacilitatorsService#get} to retrieve a Facilitator * * @param {SalesforceId} id - Contact id. match &lt;code&gt;/[\\w\\d]{15,17}/&lt;/code&gt; * @returns {Promise&lt;Response&gt;} Response body is a JSON object of type {&lt;em&gt;returned fields&lt;/em&gt;} * @memberof FacilitatorsController */ read(res, id) { return __awaiter(this, void 0, void 0, function* () { // Check the id if (!id.match(/[\\w\\d]{15,17}/)) return this.handleError(res, 'Error in FacilitatorsController.read(): ', { error: 'INVALID_SF_ID', message: `${id} is not a valid Salesforce ID.` }, common_1.HttpStatus.BAD_REQUEST); try { const facilitator = yield this.facilitatorsService.get(id); return res.status(common_1.HttpStatus.OK).json(facilitator); } catch (error) { return this.handleError(res, 'Error in FacilitatorsController.read(): ', error); } }); } /** * @desc &lt;h5&gt;POST: /facilitators&lt;/h5&gt; Calls {@link FacilitatorsService#create} to create a new Facilitator * * @param {Body} body - Required fields: &lt;code&gt;[ 'AccountId', 'FirstName', 'LastName', 'Email', 'password' ]&lt;/code&gt;&lt;br&gt;Optional fields: &lt;code&gt;[ 'roleId' ]&lt;/code&gt; * @returns {Promise&lt;Response&gt;} Response body is a JSON object. * @memberof FacilitatorsController */ create(res, body) { return __awaiter(this, void 0, void 0, function* () { if (!body.AccountId.match(/[\\w\\d]{15,17}/)) return this.handleError(res, 'Error in FacilitatorsController.create(): ', { error: 'INVALID_SF_ID', message: `${body.AccountId} is not a valid Salesforce ID.` }, common_1.HttpStatus.BAD_REQUEST); const required = objKeyValidator_1.checkRequired(body, ['AccountId', 'FirstName', 'LastName', 'Email', 'password']); if (!required.valid) return this.handleError(res, 'Error in FacilitatorsController.create(): ', { error: &quot;MISSING_FIELDS&quot;, fields: required.missing }, common_1.HttpStatus.BAD_REQUEST); try { const result = yield this.facilitatorsService.create(body); return res.status(common_1.HttpStatus.CREATED).json(result); } catch (error) { return this.handleError(res, 'Error in FacilitatorsController.create(): ', error); } }); } /** * @desc &lt;h5&gt;PUT: /facilitators/&lt;em&gt;:id&lt;/em&gt;&lt;/h5&gt; Calls {@link FacilitatorsService#update} to update a Facilitator. If &lt;code&gt;body&lt;/code&gt; contains &lt;code&gt;Email&lt;/code&gt; or &lt;code&gt;password&lt;/code&gt; the associated auth is also updated. * * @param {any} body - Required fields &lt;code&gt;{ ['Id'], oneof: ['FirstName', 'LastName', 'Email', 'password', 'Biography', etc..] }&lt;/code&gt; * @param {SalesforceId} id - Contact id. match &lt;code&gt;/[\\w\\d]{15,17}/&lt;/code&gt; * @returns {Promise&lt;Response&gt;} Response body is status of updates and resulting SF Operation * @memberof FacilitatorsController */ update(res, body, id) { return __awaiter(this, void 0, void 0, function* () { if (!id.match(/[\\w\\d]{15,17}/)) return this.handleError(res, 'Error in FacilitatorsController.update(): ', { error: 'INVALID_SF_ID', message: `${id} is not a valid Salesforce ID.` }, common_1.HttpStatus.BAD_REQUEST); if (!_.omit(body, [&quot;Id&quot;]) || !body.Id) return this.handleError(res, 'Error in FacilitatorsController.update(): ', { error: &quot;MISSING_FIELDS&quot;, fields: [&quot;Id&quot;] }, common_1.HttpStatus.BAD_REQUEST); try { const result = yield this.facilitatorsService.update(body); return res.status(common_1.HttpStatus.OK).json(result); } catch (error) { return this.handleError(res, 'Error in FacilitatorsController.update(): ', error); } }); } /** * @desc &lt;h5&gt;DELETE: /facilitators/&lt;em&gt;:id&lt;/em&gt;&lt;/h5&gt; Calls {@link FacilitatorsService#delete}, {@link FacilitatorsService#deleteAuth} or {@link FacilitatorsService#unmapAuth} to remove a facilitator from the affiliate portal * * @param {SalesforceId} id - Contact id. match &lt;code&gt;/[\\w\\d]{15,17}/&lt;/code&gt; * @param {string} [deleteAuth='true'] - Delete auth as well * @returns {Promise&lt;Response&gt;} Response is status of deletes and resulting SF Operation * @memberof FacilitatorsController */ delete(res, id, deleteAuth = 'true') { return __awaiter(this, void 0, void 0, function* () { if (!id.match(/[\\w\\d]{15,17}/)) return this.handleError(res, 'Error in FacilitatorsController.delete(): ', { error: 'INVALID_SF_ID', message: `${id} is not a valid Salesforce ID.` }, common_1.HttpStatus.BAD_REQUEST); try { const record = yield this.facilitatorsService.delete(id); let deleted = false; if (deleteAuth === 'true') deleted = yield this.facilitatorsService.deleteAuth(id); else yield this.facilitatorsService.unmapAuth(id); return res.status(common_1.HttpStatus.OK).json({ salesforce: true, auth: deleted, record }); } catch (error) { return this.handleError(res, 'Error in FacilitatorsController.delete(): ', error); } }); } /** * @desc &lt;h5&gt;DELETE: /facilitators/&lt;em&gt;:id&lt;/em&gt;/login&lt;/h5&gt; Calls {@link FacilitatorsService#deleteAuth} to delete a Facilitator's login only * * @param {SalesforceId} id - Contact id. match &lt;code&gt;/[\\w\\d]{15,17}/&lt;/code&gt; * @returns {Promise&lt;Response&gt;} Response body is result of delete * @memberof FacilitatorsController */ deleteLogin(res, id) { return __awaiter(this, void 0, void 0, function* () { if (!id.match(/[\\w\\d]{15,17}/)) return this.handleError(res, 'Error in FacilitatorsController.deleteLogin(): ', { error: 'INVALID_SF_ID', message: `${id} is not a valid Salesforce ID.` }, common_1.HttpStatus.BAD_REQUEST); try { const deleted = yield this.facilitatorsService.deleteAuth(id); return res.status(common_1.HttpStatus.OK).json({ deleted }); } catch (error) { return this.handleError(res, 'Error in FacilitatorsController.deleteLogin(): ', error); } }); } /** * @desc &lt;h5&gt;DELETE: /facilitators/&lt;em&gt;:id&lt;/em&gt;/unmap&lt;/h5&gt; Calls {@link FacilitatorsService#unmapAuth} to remove the Affiliate Portal service from a login * * @param {SalesforceId} id - Contact id. match &lt;code&gt;/[\\w\\d]{15,17}/&lt;/code&gt; * @returns {Promise&lt;Response&gt;} Reponse body is result of unmap * @memberof FacilitatorsController */ unamp(res, id) { return __awaiter(this, void 0, void 0, function* () { if (!id.match(/[\\w\\d]{15,17}/)) return this.handleError(res, 'Error in FacilitatorsController.deleteLogin(): ', { error: 'INVALID_SF_ID', message: `${id} is not a valid Salesforce ID.` }, common_1.HttpStatus.BAD_REQUEST); try { const unmaped = yield this.facilitatorsService.unmapAuth(id); return res.status(common_1.HttpStatus.OK).json({ unmaped }); } catch (error) { return this.handleError(res, 'Error in FacilitatorsController.unmap(): ', error); } }); } /** * @desc &lt;h5&gt;POST: /facilitators/&lt;em&gt;:id&lt;/em&gt;/roles/&lt;em&gt;:roleId&lt;/em&gt;&lt;/h5&gt; Calls {@link FacilitatorsService#changeRole} to change a Facilitator's role * * @param {SalesforceId} id - Contact id. match &lt;code&gt;/[\\w\\d]{15,17}/&lt;/code&gt; * @param {number} roleId - Id of the role to change too * @returns {Promise&lt;Response&gt;} Response body is result of add * @memberof FacilitatorsController */ changeRole(res, id, roleId) { return __awaiter(this, void 0, void 0, function* () { if (!id.match(/[\\w\\d]{15,17}/)) return this.handleError(res, 'Error in FacilitatorsController.changeRole(): ', { error: 'INVALID_SF_ID', message: `${id} is not a valid Salesforce ID.` }, common_1.HttpStatus.BAD_REQUEST); try { const added = this.facilitatorsService.changeRole(id, roleId); return res.status(common_1.HttpStatus.OK).json({ added }); } catch (error) { return this.handleError(res, 'Error in FacilitatorsController.changeRole(): ', error); } }); } }; __decorate([ common_1.Get(''), __param(0, common_1.Request()), __param(1, common_1.Response()), __param(2, common_1.Headers('x-affiliate')), __param(3, common_1.Headers('x-force-refresh')), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object, Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], FacilitatorsController.prototype, &quot;readAll&quot;, null); __decorate([ common_1.Get('/describe'), __param(0, common_1.Response()), __param(1, common_1.Headers('x-force-refresh')), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], FacilitatorsController.prototype, &quot;describe&quot;, null); __decorate([ common_1.Get('/search'), __param(0, common_1.Request()), __param(1, common_1.Response()), __param(2, common_1.Headers('x-search')), __param(3, common_1.Headers('x-retrieve')), __param(4, common_1.Headers('x-force-refresh')), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object, Object, Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], FacilitatorsController.prototype, &quot;search&quot;, null); __decorate([ common_1.Get('/:id'), __param(0, common_1.Response()), __param(1, common_1.Param('id')), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], FacilitatorsController.prototype, &quot;read&quot;, null); __decorate([ common_1.Post(), __param(0, common_1.Response()), __param(1, common_1.Body()), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], FacilitatorsController.prototype, &quot;create&quot;, null); __decorate([ common_1.Put('/:id'), __param(0, common_1.Response()), __param(1, common_1.Body()), __param(2, common_1.Param('id')), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], FacilitatorsController.prototype, &quot;update&quot;, null); __decorate([ common_1.Delete('/:id'), __param(0, common_1.Response()), __param(1, common_1.Param('id')), __param(2, common_1.Query('deleteAuth')), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], FacilitatorsController.prototype, &quot;delete&quot;, null); __decorate([ common_1.Delete('/:id/login'), __param(0, common_1.Response()), __param(1, common_1.Param('id')), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], FacilitatorsController.prototype, &quot;deleteLogin&quot;, null); __decorate([ common_1.Delete('/:id/unmap'), __param(0, common_1.Response()), __param(1, common_1.Param('id')), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], FacilitatorsController.prototype, &quot;unamp&quot;, null); __decorate([ common_1.Post('/:id/roles/:roleId'), __param(0, common_1.Response()), __param(1, common_1.Param('id')), __param(2, common_1.Param('roleId')), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], FacilitatorsController.prototype, &quot;changeRole&quot;, null); FacilitatorsController = __decorate([ common_1.Controller('facilitators'), __metadata(&quot;design:paramtypes&quot;, [components_1.FacilitatorsService]) ], FacilitatorsController); exports.FacilitatorsController = FacilitatorsController; × Search results Close "},"components_facilitators_facilitators.component.js.html":{"id":"components_facilitators_facilitators.component.js.html","title":"Source: components/facilitators/facilitators.component.js","body":" Shingo Affiliate Portal Classes AffiliatesControllerAffiliatesServiceAuthControllerAuthServiceBaseControllerCacheServiceFacilitatorsControllerFacilitatorsServiceSalesforceServiceUserServiceWorkshopsControllerWorkshopsService Source: components/facilitators/facilitators.component.js &quot;use strict&quot;; var __decorate = (this &amp;&amp; this.__decorate) || function (decorators, target, key, desc) { var c = arguments.length, r = c &lt; 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d; if (typeof Reflect === &quot;object&quot; &amp;&amp; typeof Reflect.decorate === &quot;function&quot;) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i &gt;= 0; i--) if (d = decorators[i]) r = (c &lt; 3 ? d(r) : c &gt; 3 ? d(target, key, r) : d(target, key)) || r; return c &gt; 3 &amp;&amp; r &amp;&amp; Object.defineProperty(target, key, r), r; }; var __metadata = (this &amp;&amp; this.__metadata) || function (k, v) { if (typeof Reflect === &quot;object&quot; &amp;&amp; typeof Reflect.metadata === &quot;function&quot;) return Reflect.metadata(k, v); }; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const common_1 = require(&quot;@nestjs/common&quot;); const _1 = require(&quot;../&quot;); const _ = require(&quot;lodash&quot;); /** * @desc A service to provide functions for working with Facilitators * * @export * @class FacilitatorsService */ let FacilitatorsService = class FacilitatorsService { constructor() { this.sfService = new _1.SalesforceService(); this.authService = new _1.AuthService(); this.cache = new _1.CacheService(); } /** * @desc Get all facilitators for the affiliate specified. All if &lt;code&gt;affiliate === ''&lt;/code&gt;. The queried fields from Salesforce are as follows:&lt;br&gt;&lt;br&gt; * &lt;code&gt;[&lt;br&gt; * &amp;emsp;&quot;Id&quot;,&lt;br&gt; * &amp;emsp;&quot;FirstName&quot;,&lt;br&gt; * &amp;emsp;&quot;LastName&quot;,&lt;br&gt; * &amp;emsp;&quot;Email&quot;,&lt;br&gt; * &amp;emsp;&quot;Title&quot;,&lt;br&gt; * &amp;emsp;&quot;Account.Id&quot;,&lt;br&gt; * &amp;emsp;&quot;Account.Name&quot;,&lt;br&gt; * &amp;emsp;&quot;Facilitator_For\\__r.Id&quot;,&lt;br&gt; * &amp;emsp;&quot;Facilitator_For\\__r.Name&quot;,&lt;br&gt; * &amp;emsp;&quot;Photograph\\__c&quot;,&lt;br&gt; * &amp;emsp;&quot;Biography\\__c&quot;&lt;br&gt; * ]&lt;/code&gt; * * @param {User} user - Requires &lt;code&gt;user.permissions[]&lt;/code&gt; and &lt;code&gt;user.roles[].permissions[]&lt;/code&gt; * @param {boolean} [refresh=false] - Force the refresh of the cache * @param {string} [affiliate] - SF Id of the affiliate to get facilitators for (or '' to get all facilitators) * @returns {Promise&lt;any[]&gt;} * @memberof FacilitatorsService */ getAll(user, refresh = false, affiliate) { return __awaiter(this, void 0, void 0, function* () { let isAfMan = false; for (let role of user.roles) { if (role.name === 'Affiliate Manager') isAfMan = true; } let query = { action: &quot;SELECT&quot;, fields: [ &quot;Id&quot;, &quot;FirstName&quot;, &quot;LastName&quot;, &quot;Email&quot;, &quot;Title&quot;, &quot;Account.Id&quot;, &quot;Account.Name&quot;, &quot;Facilitator_For__r.Id&quot;, &quot;Facilitator_For__r.Name&quot;, &quot;Photograph__c&quot;, &quot;Biography__c&quot; ], table: &quot;Contact&quot;, clauses: `RecordType.Name='Affiliate Instructor'` }; if (affiliate != '') query.clauses += ` AND Facilitator_For__c='${affiliate}'`; if (!this.cache.isCached(query) || refresh) { const facilitators = yield this.sfService.query(query); this.cache.cache(query, facilitators); return Promise.resolve(facilitators.records); } else { return Promise.resolve(this.cache.getCache(query)); } }); } /** * @desc Uses the Salesforce REST API to describe the Contact object. See the Salesforce documentation for more about 'describe' * * @param {boolean} [refresh=false] - Force the refresh of the cache * @returns {Promise&lt;any&gt;} * @memberof FacilitatorsService */ describe(refresh = false) { return __awaiter(this, void 0, void 0, function* () { const key = 'describeContacts'; if (!this.cache.isCached(key) || refresh) { const describeObject = yield this.sfService.describe('Contact'); this.cache.cache(key, describeObject); return Promise.resolve(describeObject); } else { return Promise.resolve(this.cache.getCache(key)); } }); } /** * @desc Executes a SOSL query to search for text on Contacts of record type Affiliate Instructor Salesforce. Example response body:&lt;br&gt;&lt;br&gt; * &lt;code&gt;[&lt;br&gt; * &amp;emsp;{&lt;br&gt; * &amp;emsp;&amp;emsp;&quot;Id&quot;: &quot;003g000001VvwEZAAZ&quot;,&lt;br&gt; * &amp;emsp;&amp;emsp;&quot;Name&quot;: &quot;Test One&quot;,&lt;br&gt; * &amp;emsp;&amp;emsp;&quot;Email&quot;: &quot;testone@example.com&quot;&lt;br&gt; * &amp;emsp;},&lt;br&gt; * &amp;emsp;{&lt;br&gt; * &amp;emsp;&amp;emsp;&quot;Id&quot;: &quot;003g000001VvwEZABA&quot;,&lt;br&gt; * &amp;emsp;&amp;emsp;&quot;Name&quot;: &quot;Test Two&quot;,&lt;br&gt; * &amp;emsp;&amp;emsp;&quot;Email&quot;: &quot;testtwo@example.com&quot;&lt;br&gt; * &amp;emsp;},&lt;br&gt; * &amp;emsp;{&lt;br&gt; * &amp;emsp;&amp;emsp;&quot;Id&quot;: &quot;003g000001VvwEZABB&quot;,&lt;br&gt; * &amp;emsp;&amp;emsp;&quot;Name&quot;: &quot;Test Three&quot;,&lt;br&gt; * &amp;emsp;&amp;emsp;&quot;Email&quot;: &quot;testthree@example.com&quot;&lt;br&gt; * &amp;emsp;},&lt;br&gt; * ]&lt;/code&gt; * * @param {Header} search - Header 'x-search'. SOSL search expression (i.e. '*Test*'). * @param {Header} retrieve - Header 'x-retrieve'. A comma seperated list of the Contact fields to retrieve (i.e. 'Id, Name, Email') * @param {string} [affiliate=''] - The SF Id to filter results for (or '' for no filter) * @param {boolean} [isAfMan=false] - Is request coming from an Affiliate Manager * @param {boolean} [refresh=false] - Force the refresh of the cache * @returns {Promise&lt;any&gt;} * @memberof FacilitatorsService */ search(search, retrieve, affiliate = '', isAfMan = false, refresh = false) { return __awaiter(this, void 0, void 0, function* () { // Generate the data parameter for the RPC call if (!retrieve.includes('AccountId')) retrieve += ', AccountId'; if (!retrieve.includes('RecordType.Name')) retrieve += ', RecordType.Name'; const data = { search: `{${search}}`, retrieve: `Contact(${retrieve})` }; if (!this.cache.isCached(data) || refresh) { const facilitators = (yield this.sfService.search(data)).searchRecords.filter(result =&gt; { if (affiliate === '') return result.RecordType.Name === 'Affiliate Instructor'; else return result.AccountId === affiliate &amp;&amp; result.RecordType.Name === 'Affiliate Instructor'; }); this.cache.cache(data, facilitators); return Promise.resolve(facilitators); } else { return Promise.resolve(this.cache.getCache(data)); } }); } /** * @desc Get the facilitator with the id passed at the parameter :id. The following fields are returned:&lt;br&gt;&lt;br&gt; * &lt;code&gt;[&lt;br&gt; * TODO: Add fields that are returned&lt;br&gt; * ]&lt;/code&gt; * * @param {string} id - Salesforce ID for a Contact * @returns {Promise&lt;any&gt;} * @memberof FacilitatorsService */ get(id) { return __awaiter(this, void 0, void 0, function* () { // Create the data parameter for the RPC call const data = { object: 'Contact', ids: [id] }; const facilitator = (yield this.sfService.retrieve(data))[0]; const user = yield this.authService.getUser(`user.email='${facilitator.Email}'`); return Promise.resolve(_.merge(facilitator, _.omit(user, ['email', 'password']))); }); } /** * @desc Creates a new Contact of record type 'Affiliate Instructor' in Salesforce and addes a user to the Shingo Auth api. The user create for the Auth API will be assigned the role of roleId (defaults to 'Facilitator'). Returns a response like:&lt;br&gt;&lt;br&gt; * &lt;code&gt;{&lt;br&gt; * &amp;emsp;&quot;jwt&quot;: string,&lt;br&gt; * &amp;emsp;&quot;id:&quot; number&lt;br&gt; * }&lt;/code&gt; * * @param {any} user - User to create * @returns {Promise&lt;any&gt;} * @memberof FacilitatorsService */ create(user) { return __awaiter(this, void 0, void 0, function* () { const roleId = (user.roleId ? user.roleId : global['facilitatorId']); let contact = _.omit(user, [&quot;password&quot;, &quot;roleId&quot;]); // Create the contact in Salesforce contact.RecordTypeId = '012A0000000zpqrIAA'; const data = { object: 'Contact', records: [{ contents: JSON.stringify(contact) }] }; const record = (yield this.sfService.create(data))[0]; let auth = yield this.authService.getUser(`user.email='${user.Email}'`); console.log('auth', auth); if (auth.email === '') { auth = yield this.createNewAuth(user.Email, user.password, roleId, record.id); } else { auth = yield this.mapCurrentAuth(user.Email, roleId, record.id); } return Promise.resolve(Object.assign({ id: record.id }, auth)); }); } /** * @desc Uses the Shingo Auth API to create a new login * * @param {string} email * @param {string} password * @param {number} roleId * @param {string} extId - Salesforce Id of the associated contact * @returns {Promise&lt;any&gt;} * @memberof FacilitatorsService */ createNewAuth(email, password, roleId, extId) { return __awaiter(this, void 0, void 0, function* () { const user = yield this.authService.createUser({ email, password, services: 'affiliate-portal', extId }); yield this.authService.addRoleToUser({ userEmail: email, roleId }); return Promise.resolve({ jwt: user.jwt, id: user.id }); }); } /** * @desc Uses the Shingo Auth API to map a Salesforce contact to a current login * * @param {string} userEmail * @param {number} roleId * @param {string} extId - Salesforce Id of the associated contact * @returns {Promise&lt;any&gt;} * @memberof FacilitatorsService */ mapCurrentAuth(userEmail, roleId, extId) { return __awaiter(this, void 0, void 0, function* () { const user = yield this.authService.getUser(`user.email='${userEmail}'`); if (user === undefined) Promise.reject({ error: 'USER_NOT_FOUND' }); user.extId = extId; user.services = (user.services === '' ? 'affiliate-portal' : user.services + ', affiliate-portal'); yield this.authService.updateUser(user); yield this.authService.addRoleToUser({ userEmail, roleId }); return Promise.resolve({ jwt: user.jwt, id: user.id }); }); } /** * @desc Updates a facilitator's fields. Returns the following:&lt;br&gt;&lt;br&gt; * &lt;code&gt;{&lt;br&gt; * &amp;emsp;&quot;record&quot;: {&lt;br&gt; * &amp;emsp;&amp;emsp;&quot;id&quot;: SalesforceId,&lt;br&gt; * &amp;emsp;&amp;emsp;&quot;success&quot;: boolean,&lt;br&gt; * &amp;emsp;&amp;emsp;&quot;errors&quot;: []&lt;br&gt; * &amp;emsp;},&lt;br&gt; * &amp;emsp;&quot;salesforce&quot;: boolean,&lt;br&gt; * &amp;emsp;&quot;auth&quot;: boolean * }&lt;/code&gt; * * @param {any} user - The facilitator's fields to update * @returns {Promise&lt;any&gt;} * @memberof FacilitatorsService */ update(user) { return __awaiter(this, void 0, void 0, function* () { const contact = _.omit(user, [&quot;password&quot;]); const data = { object: 'Contact', records: [{ contents: JSON.stringify(contact) }] }; const record = (yield this.sfService.update(data))[0]; if (user.Email || user.password) { return Promise.resolve({ salesforce: true, auth: yield this.updateAuth(user, record.id), record }); } return Promise.resolve({ salesforce: true, auth: false, record }); }); } /** * @desc Update the associated login of a facilitator * * @param {any} user - Facilitator's fields to update * @param {any} extId - Facilitator's Contact ID * @returns {Promise&lt;boolean&gt;} * @memberof FacilitatorsService */ updateAuth(user, extId) { return __awaiter(this, void 0, void 0, function* () { const set = { extId }; if (user.Email) set['email'] = user.Email; if (user.password) set['password'] = user.password; console.log('set: ', set); const updated = yield this.authService.updateUser(set); console.log('updated', updated); return Promise.resolve((updated &amp;&amp; updated.response)); }); } /** * @desc Deletes a facilitator. Returns the following:&lt;br&gt;&lt;br&gt; * &lt;code&gt;{&lt;br&gt; * &amp;emsp;&quot;id&quot;: SalesforceId,&lt;br&gt; * &amp;emsp;&quot;success&quot;: boolean,&lt;br&gt; * &amp;emsp;&quot;errors&quot;: []&lt;br&gt; * }&lt;/code&gt; * * * @param {string} id - Salesforce Id of the Contact to delete * @returns {Promise&lt;any&gt;} * @memberof FacilitatorsService */ delete(id) { return __awaiter(this, void 0, void 0, function* () { // Create the data parameter for the RPC call const data = { object: 'Contact', ids: [id] }; const record = (yield this.sfService.delete(data))[0]; return Promise.resolve(record); }); } /** * @desc Delete a login from the Shingo Auth API * * @param {string} extId - Facilitator's Contact Id * @returns {Promise&lt;boolean&gt;} * @memberof FacilitatorsService */ deleteAuth(extId) { return __awaiter(this, void 0, void 0, function* () { const deleted = yield this.authService.deleteUser({ extId }); return Promise.resolve(deleted &amp;&amp; deleted.response); }); } /** * @desc Remove the Affiliate Portal as service for a login * * @param {string} extId - Facilitator's Contact Id * @returns {Promise&lt;boolean&gt;} * @memberof FacilitatorsService */ unmapAuth(extId) { return __awaiter(this, void 0, void 0, function* () { const user = yield this.authService.getUser(`user.extId='${extId}'`); if (user === undefined) return Promise.reject({ error: 'USER_NOT_FOUND' }); if (user.services === 'affiliate-portal') user.services = ''; else if (user.services.includes(', affiliate-portal')) user.services = user.services.replace(', affiliate-portal', ''); else if (user.services.includes('affiliate-portal, ')) user.services = user.services.replace('affiliate-portal', ''); const updated = yield this.authService.updateUser(user); return Promise.resolve(updated &amp;&amp; updated.resolve); }); } /** * @desc Change a Facilitator's role to the role specified by &lt;code&gt;roleId&lt;/code&gt;. If a role exists that belongs to the Affiliate Portal, it is removed first * * @param {string} extId - Facilitator's Contact Id * @param {any} roleId - Id of the role to change to * @returns {Promise&lt;boolean&gt;} * @memberof FacilitatorsService */ changeRole(extId, roleId) { return __awaiter(this, void 0, void 0, function* () { const user = yield this.authService.getUser(`user.extId='${extId}'`); if (user === undefined) return Promise.reject({ error: 'USER_NOT_FOUND' }); const currentRole = user.roles.filter(role =&gt; { return role.service === 'affiliate-portal'; }); const set = { userEmail: user.email, roleId }; if (currentRole !== undefined) { yield this.authService.removeRoleFromUser({ userEmail: user.email, roleId: currentRole.id }); } const added = yield this.authService.addRoleToUser(set); return Promise.resolve(added &amp;&amp; added.response); }); } }; FacilitatorsService = __decorate([ common_1.Component(), __metadata(&quot;design:paramtypes&quot;, []) ], FacilitatorsService); exports.FacilitatorsService = FacilitatorsService; × Search results Close "},"components_salesforce_salesforce.component.js.html":{"id":"components_salesforce_salesforce.component.js.html","title":"Source: components/salesforce/salesforce.component.js","body":" Shingo Affiliate Portal Classes AffiliatesControllerAffiliatesServiceAuthControllerAuthServiceBaseControllerCacheServiceFacilitatorsControllerFacilitatorsServiceSalesforceServiceUserServiceWorkshopsControllerWorkshopsService Source: components/salesforce/salesforce.component.js &quot;use strict&quot;; var __decorate = (this &amp;&amp; this.__decorate) || function (decorators, target, key, desc) { var c = arguments.length, r = c &lt; 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d; if (typeof Reflect === &quot;object&quot; &amp;&amp; typeof Reflect.decorate === &quot;function&quot;) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i &gt;= 0; i--) if (d = decorators[i]) r = (c &lt; 3 ? d(r) : c &gt; 3 ? d(target, key, r) : d(target, key)) || r; return c &gt; 3 &amp;&amp; r &amp;&amp; Object.defineProperty(target, key, r), r; }; var __metadata = (this &amp;&amp; this.__metadata) || function (k, v) { if (typeof Reflect === &quot;object&quot; &amp;&amp; typeof Reflect.metadata === &quot;function&quot;) return Reflect.metadata(k, v); }; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const common_1 = require(&quot;@nestjs/common&quot;); const grpc = require(&quot;grpc&quot;); const path = require(&quot;path&quot;); const bluebird = require(&quot;bluebird&quot;); const sfservices = grpc.load(path.join(__dirname, '../../../proto/sf_services.proto')).sfservices; /** * @desc A service to abastract the Shingo SF Microservice client * * @export * @class SalesforceService */ let SalesforceService = class SalesforceService { constructor() { this.client = bluebird.promisifyAll(this.getClient()); } /** * @desc Method to instantiate a RPC Client from the sf_services.proto * * @private * @returns Returns a RPC Client to be used in consuming the Shingo SF Microservice * @memberof SalesforceService */ getClient() { return new sfservices.SalesforceMicroservices(`${process.env.SF_API}:80`, grpc.credentials.createInsecure()); } /** * @desc Async wrapper for the Shingo SF Microservice query call * * @param {SFQueryObject} query - See {@link SFQueryObject} * @returns {Promise&lt;SFQueryResponse&gt;} See {@link SFQueryResponse} * @memberof SalesforceService */ query(query) { return __awaiter(this, void 0, void 0, function* () { const response = yield this.client.queryAsync(query); return Promise.resolve(JSON.parse(response.contents)); }); } /** * @desc Async wrapper for the Shingo SF Microservice retrieve call * * @param {SFIdData} data - See {@link SFIdData} * @returns {Promise&lt;object&gt;} * @memberof SalesforceService */ retrieve(data) { return __awaiter(this, void 0, void 0, function* () { const response = yield this.client.retrieveAsync(data); return Promise.resolve(JSON.parse(response.contents)); }); } /** * @desc Async wrapper for the Shingo SF Microservice create call * * @param {SFRecordData} data - See {@link SFRecordData} * @returns {Promise&lt;SFSuccessObject[]&gt;} - See {@link SFSuccessObject} * @memberof SalesforceService */ create(data) { return __awaiter(this, void 0, void 0, function* () { const response = yield this.client.createAsync(data); return Promise.resolve(JSON.parse(response.contents)); }); } /** * @desc Async wrapper for the Shingo SF Microservice update call * * @param {SFRecordData} data - See {@link SFRecordData} * @returns {Promise&lt;SFSuccessObject[]&gt;} - See {@link SFSuccessObject} * @memberof SalesforceService */ update(data) { return __awaiter(this, void 0, void 0, function* () { const response = yield this.client.updateAsync(data); return Promise.resolve(JSON.parse(response.contents)); }); } /** * @desc Async wrapper for the Shingo SF Microservice delete call * * @param {SFIdData} data - See {@link SFIdData} * @returns {Promise&lt;SFSuccessObject[]&gt;} - See {@link SFSuccessObject} * @memberof SalesforceService */ delete(data) { return __awaiter(this, void 0, void 0, function* () { const response = yield this.client.deleteAsync(data); return Promise.resolve(JSON.parse(response.contents)); }); } /** * @desc Async wrapper for the Shingo SF Microservice describe call * * @param {string} object - SF Object to describe * @returns {Promise&lt;object&gt;} - See {@linkhttps://developer.salesforce.com/docs/atlas.en-us.api_rest.meta/api_rest/dome_sobject_describe.htm|Salesforce Docs} * @memberof SalesforceService */ describe(object) { return __awaiter(this, void 0, void 0, function* () { const response = yield this.client.describeAsync({ object }); return Promise.resolve(JSON.parse(response.contents)); }); } /** * @desc Async wrapper for the Shingo SF Microservice search call * * @param {SFSearchData} data - See {@link SFSearchData} * @returns {Promise&lt;SFSearchResults&gt;} - Array of workshops * @memberof SalesforceService */ search(data) { return __awaiter(this, void 0, void 0, function* () { const response = yield this.client.searchAsync(data); return Promise.resolve(JSON.parse(response.contents)); }); } /** * @desc Utility method to assist in parsing gRPC error metadata. Returns a JSON object from the parsed error data. If no JSON object can be parsed, the method attempts to return the 'error-bin' from the meta-data as a string. If that fails the method returns the error passed to it. * * @static * @param {gRPCError} error - The error to be parsed * @returns {object} The parsed error, 'error-bin'.toString(), or passed in error * @memberof SalesforceService */ static parseRPCErrorMeta(error) { try { let err = JSON.parse(error.metadata.get('error-bin').toString()); return err; } catch (caught) { console.error('Couldn\\'t parse RPC Error;', { error, caught }); if (error.metadata.get('error-bin')) return error.metadata.get('error-bin').toString(); else return error; } } }; SalesforceService = __decorate([ common_1.Component(), __metadata(&quot;design:paramtypes&quot;, []) ], SalesforceService); exports.SalesforceService = SalesforceService; × Search results Close "},"components_user_user.component.js.html":{"id":"components_user_user.component.js.html","title":"Source: components/user/user.component.js","body":" Shingo Affiliate Portal Classes AffiliatesControllerAffiliatesServiceAuthControllerAuthServiceBaseControllerCacheServiceFacilitatorsControllerFacilitatorsServiceSalesforceServiceUserServiceWorkshopsControllerWorkshopsService Source: components/user/user.component.js &quot;use strict&quot;; var __decorate = (this &amp;&amp; this.__decorate) || function (decorators, target, key, desc) { var c = arguments.length, r = c &lt; 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d; if (typeof Reflect === &quot;object&quot; &amp;&amp; typeof Reflect.decorate === &quot;function&quot;) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i &gt;= 0; i--) if (d = decorators[i]) r = (c &lt; 3 ? d(r) : c &gt; 3 ? d(target, key, r) : d(target, key)) || r; return c &gt; 3 &amp;&amp; r &amp;&amp; Object.defineProperty(target, key, r), r; }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const common_1 = require(&quot;@nestjs/common&quot;); /** * @desc Provide methods for working with users * * @export * @class UserService */ let UserService = class UserService { /** * @desc Parse out the workshops that a user has permissions for * * @param {any} user - Requires &lt;code&gt;user.permissions[]&lt;/code&gt; and &lt;code&gt;user.roles[].permissions[]&lt;/code&gt; * @returns {string[]} * @memberof UserService */ getWorkshopIds(user) { let ids = []; user.permissions.forEach(p =&gt; { if (p.resource.includes('/workshops/')) ids.push(`'${p.resource.replace('/workshops/', '')}'`); }); user.roles.forEach(role =&gt; { role.permissions.forEach(p =&gt; { if (p.resource.includes('/workshops/')) ids.push(`'${p.resource.replace('/workshops/', '')}'`); }); }); return [...new Set(ids)]; // Only return unique ids } }; UserService = __decorate([ common_1.Component() ], UserService); exports.UserService = UserService; × Search results Close "},"controllers_workshops_workshops.controller.js.html":{"id":"controllers_workshops_workshops.controller.js.html","title":"Source: controllers/workshops/workshops.controller.js","body":" Shingo Affiliate Portal Classes AffiliatesControllerAffiliatesServiceAuthControllerAuthServiceBaseControllerCacheServiceFacilitatorsControllerFacilitatorsServiceSalesforceServiceUserServiceWorkshopsControllerWorkshopsService Source: controllers/workshops/workshops.controller.js &quot;use strict&quot;; var __decorate = (this &amp;&amp; this.__decorate) || function (decorators, target, key, desc) { var c = arguments.length, r = c &lt; 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d; if (typeof Reflect === &quot;object&quot; &amp;&amp; typeof Reflect.decorate === &quot;function&quot;) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i &gt;= 0; i--) if (d = decorators[i]) r = (c &lt; 3 ? d(r) : c &gt; 3 ? d(target, key, r) : d(target, key)) || r; return c &gt; 3 &amp;&amp; r &amp;&amp; Object.defineProperty(target, key, r), r; }; var __metadata = (this &amp;&amp; this.__metadata) || function (k, v) { if (typeof Reflect === &quot;object&quot; &amp;&amp; typeof Reflect.metadata === &quot;function&quot;) return Reflect.metadata(k, v); }; var __param = (this &amp;&amp; this.__param) || function (paramIndex, decorator) { return function (target, key) { decorator(target, key, paramIndex); } }; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const common_1 = require(&quot;@nestjs/common&quot;); const components_1 = require(&quot;../../components&quot;); const base_controller_1 = require(&quot;../base.controller&quot;); const objKeyValidator_1 = require(&quot;../../validators/objKeyValidator&quot;); const multer = require(&quot;multer&quot;); /** * @desc Controller of the REST API logic for Workshops * * @export * @class WorkshopsController * @extends {BaseController} */ let WorkshopsController = class WorkshopsController extends base_controller_1.BaseController { constructor(workshopsService, log) { super(); this.workshopsService = workshopsService; this.log = log; } ; /** * @desc &lt;h5&gt;GET: /workshops&lt;/h5&gt; Calls {@link WorkshopsService#getAll} to get an array of Workshops * * @param {Session} session - Session contains the current user. The function uses the permissions on this object to query Salesforce for the workshops. * @param {any} isPublicQ - Query parameter &lt;code&gt;'isPublic'&lt;/code&gt;; Expected values &lt;code&gt;[ 'true', 'false' ]&lt;/code&gt;; Alias &lt;code&gt;headers['x-force-refesh']&lt;/code&gt;; Returns public workshops * @param {any} isPublicH - Header &lt;code&gt;'x-is-public'&lt;/code&gt;; Expected values &lt;code&gt;[ 'true', 'false' ]&lt;/code&gt;; Alias &lt;code&gt;query['isPublic']&lt;/code&gt;; Returns public workshops * @param {Header} [refresh='false'] - Header &lt;code&gt;'x-force-refresh'&lt;/code&gt;; Expected values &lt;code&gt;[ 'true', 'false' ]&lt;/code&gt;; Forces cache refresh * @returns {Promise&lt;Response&gt;} Response body contains a JSON array of Workshops * @memberof WorkshopsController */ readAll(res, session, isPublicQ, isPublicH, refresh = 'false') { return __awaiter(this, void 0, void 0, function* () { const isPublic = (isPublicQ === 'true' || isPublicH === 'true'); const forceRefresh = refresh === 'true'; if (!session.user &amp;&amp; !isPublic) return this.handleError(res, 'Error in WorkshopsController.readAll()', { error: &quot;SESSION_EXPIRED&quot; }, common_1.HttpStatus.FORBIDDEN); try { const workshops = yield this.workshopsService.getAll(isPublic, forceRefresh, session.user); this.log.silly('Returning workshops: %j', workshops); return res.status(common_1.HttpStatus.OK).json(workshops); } catch (error) { return this.handleError(res, 'Error in WorkshopsController.readAll(): ', error); } }); } /** * @desc &lt;h5&gt;GET: /workshops/describe&lt;/h5&gt; Calls {@link WorkshopsService#describe} to describe Workshop\\__c * * @param {Header} [refresh='false'] - Header &lt;code&gt;'x-force-refresh'&lt;/code&gt;; Expected values &lt;code&gt;[ 'true', 'false' ]&lt;/code&gt;; Forces cache refresh * @returns {Promise&lt;Response&gt;} Response body is a JSON object with the describe result * @memberof WorkshopsController */ describe(res, refresh = 'false') { return __awaiter(this, void 0, void 0, function* () { try { const describeObject = yield this.workshopsService.describe(refresh === 'true'); return res.status(common_1.HttpStatus.OK).json(describeObject); } catch (error) { return this.handleError(res, 'Error in WorkshopsController.describe(): ', error); } }); } /** * @desc &lt;h5&gt;GET: /workshops/search&lt;/h5&gt; Calls {@link WorkshopsService#search}. Returns an array of workshops that match search criteria * * * @param {Header} search - Header &lt;code&gt;'x-search'&lt;/code&gt;. SOSL search expression (i.e. '*Discover Test*'). * @param {Header} retrieve - Header &lt;code&gt;'x-retrieve'&lt;/code&gt;. A comma seperated list of the Workshop\\__c fields to retrieve (i.e. 'Id, Name, Start_Date\\__c') * @param {Header} [refresh='false'] - Header &lt;code&gt;'x-force-refresh'&lt;/code&gt;; Expected values &lt;code&gt;[ 'true', 'false' ]&lt;/code&gt;; Forces cache refresh * @returns {Promise&lt;Response&gt;} Response body is a JSON Array of workshops * @memberof WorkshopsController */ search(res, search, retrieve, refresh = 'false') { return __awaiter(this, void 0, void 0, function* () { // Check for required fields if (!search || !retrieve) return this.handleError(res, 'Error in WorkshopsController.search(): ', { error: 'MISSING_PARAMETERS', params: (!search &amp;&amp; !retrieve ? ['search', 'retrieve '] : !search ? ['search'] : ['retrieve']) }, common_1.HttpStatus.BAD_REQUEST); try { const workshops = yield this.workshopsService.search(search, retrieve, refresh === 'true'); return res.status(common_1.HttpStatus.OK).json(workshops); } catch (error) { return this.handleError(res, 'Error in WorkshopsController.search(): ', error); } }); } /** * @desc &lt;h5&gt;GET: /workshops/&lt;em&gt;:id&lt;/em&gt;&lt;/h5&gt; Calls {@link WorkshopsService#get} to retrieve a specific workshop * * @param {SalesforceId} id - Workshop\\__c id. match &lt;code&gt;/a[\\w\\d]{14,17}/&lt;/code&gt; * @returns {Promise&lt;Response&gt;} Response body is a JSON object of type {&lt;em&gt;returned fields&lt;/em&gt;} * @memberof WorkshopsController */ read(res, id) { return __awaiter(this, void 0, void 0, function* () { // Check the id if (!id.match(/a[\\w\\d]{14,17}/)) return this.handleError(res, 'Error in WorkshopsController.read(): ', { error: 'INVALID_SF_ID', message: `${id} is not a valid Salesforce ID.` }, common_1.HttpStatus.BAD_REQUEST); try { const workshop = yield this.workshopsService.get(id); return res.status(common_1.HttpStatus.OK).json(workshop); } catch (error) { return this.handleError(res, 'Error in WorkshopsController.read(): ', error); } }); } /** * @desc &lt;h5&gt;GET: /workshops/&lt;em&gt;:id&lt;/em&gt;/facilitators&lt;/h5&gt; Calls {@link WorkshopsService#facilitators} to get all associated facilitators for a workshop * * @param {SalesforceId} id - Workshop\\__cid. match &lt;code&gt;/a[\\w\\d]{14,17}/&lt;/code&gt; * @returns {Promise&lt;Response&gt;} Response is a JSON Array of Contact objects * @memberof WorkshopsController */ facilitators(res, id) { return __awaiter(this, void 0, void 0, function* () { // Check the id if (!id.match(/a[\\w\\d]{14,17}/)) this.handleError(res, 'Error in WorkshopsController.facilitators(): ', { error: 'INVALID_SF_ID', message: `${id} is not a valid Salesforce ID.` }, common_1.HttpStatus.BAD_REQUEST); try { const facilitators = yield this.workshopsService.facilitators(id); return res.status(common_1.HttpStatus.OK).json(facilitators); } catch (error) { return this.handleError(res, 'Error in WorkshopsController.facilitators(): ', error); } }); } /** * @desc &lt;h5&gt;POST: /workshops&lt;/h5&gt; Calls {@link WorkshopsService#create} to create a new workshop in Salesforce and permissions for the workshop in the Shingo Auth API * * @param {Body} body - Required fields &lt;code&gt;[ &quot;Name&quot;, &quot;Organizing_Affiliate\\__c&quot;, &quot;Start_Date\\__c&quot;, &quot;End_Date\\__c&quot;, &quot;Host_Site\\__c&quot;, &quot;Event_Country\\__c&quot;, &quot;Event_City\\__c&quot;, &quot;facilitators&quot; ]&lt;/code&gt; * @param {Session} session - Accesses the affiliate id from the session to compare to the Organizaing_Affiliate\\__c on the body * @returns {Promise&lt;Response&gt;} Response is a JSON Object from the resulting Salesforce operation * @memberof WorkshopsController */ create(res, body, session) { return __awaiter(this, void 0, void 0, function* () { // Check required parameters let valid = objKeyValidator_1.checkRequired(body, ['Name', 'Organizing_Affiliate__c', 'Start_Date__c', 'End_Date__c', 'Host_Site__c', 'Event_Country__c', 'Event_City__c', 'facilitators']); if (!session.affiliate || !valid.valid) { if (!session.affiliate) return this.handleError(res, 'Error in WorkshopsController.create(): ', { error: 'SESSION_EXPIRED' }, common_1.HttpStatus.FORBIDDEN); return this.handleError(res, 'Error in WorkshopsController.create(): ', { error: 'MISSING_FIELD', fields: valid.missing }, common_1.HttpStatus.BAD_REQUEST); } // Check for valid SF ID on Organizing_Affiliate\\__c if (!body.Organizing_Affiliate__c.match(/[\\w\\d]{15,17}/)) return this.handleError(res, 'Error in WorkshopsController.create(): ', { error: 'INVALID_SF_ID', message: `${body.Organizing_Affiliate__c} is not a valid Salesforce ID.` }, common_1.HttpStatus.BAD_REQUEST); // Check can create for Organizing_Affiliate\\__c if (session.affiliate !== 'ALL' &amp;&amp; session.affiliate !== body.Organizing_Affiliate__c) return this.handleError(res, 'Error in WorkshopsController.create(): ', { error: 'PERM_DENIDED', message: `You are not allowed to post workshops for the Affiliate with Id ${body.Organizing_Affiliate__c}` }, common_1.HttpStatus.FORBIDDEN); try { const sfSuccess = yield this.workshopsService.create(body); return res.status(common_1.HttpStatus.CREATED).json(sfSuccess); } catch (error) { return this.handleError(res, 'Error in WorkshopsController.create(): ', error); } }); } /** * @desc &lt;h5&gt;PUT: /workshops/&lt;em&gt;:id&lt;/em&gt;&lt;/h5&gt; Calls {@link WorkshopsService#update} to update a workshop's fields. This function also updates facilitator associations and permissions * * @param {Body} body - Required fields &lt;code&gt;[ &quot;Id&quot;, &quot;Organizing_Affiliate\\__c&quot; ]&lt;/code&gt; * @param {Session} session - Accesses the affiliate id from the session to compare to the Organizaing_Affiliate\\__c on the body * @param {SalesforceId} id - Workshop\\__c id. match &lt;code&gt;/a[\\w\\d]{14,17}/&lt;/code&gt; * @returns {Promise&lt;Response&gt;} Response is a JSON Object from the resulting Salesforce operation * @memberof WorkshopsController */ update(res, id, body, session) { return __awaiter(this, void 0, void 0, function* () { // Check required parameters let required = objKeyValidator_1.checkRequired(body, ['Id', 'Organizing_Affiliate__c']); if (!session.affiliate || !required.valid) { if (!session.affiliate) return this.handleError(res, 'Error in WorkshopsController.update(): ', { error: 'SESSION_EXPIRED' }, common_1.HttpStatus.FORBIDDEN); return this.handleError(res, 'Error in WorkshopsController.update(): ', { error: 'MISSING_FIELD', fields: required.missing }, common_1.HttpStatus.BAD_REQUEST); } // Check the id const pattern = /[\\w\\d]{15,17}/; if (!pattern.test(id) || !pattern.test(body.Id) || id !== body.Id || !pattern.test(body.Organizing_Affiliate__c)) { return this.handleError(res, 'Error in WorkshopsController.update(): ', { error: 'INVALID_SF_ID', message: `${body.Organizing_Affiliate__c} or ${id} or ${body.Id} is not a valid Salesforce ID.` }, common_1.HttpStatus.BAD_REQUEST); } // Check can update for Organizing_Affiliate\\__c if (session.affiliate !== 'ALL' &amp;&amp; session.affiliate !== body.Organizing_Affiliate__c) { return this.handleError(res, 'Error in WorkshopsController.update(): ', { error: 'PERM_DENIDED', message: `You are not allowed to update workshops for the Affiliate with Id ${body.Organizing_Affiliate__c}` }, common_1.HttpStatus.FORBIDDEN); } try { const result = yield this.workshopsService.update(body); return res.status(common_1.HttpStatus.OK).json(result); } catch (error) { return this.handleError(res, 'Error in WorkshopsController.update(): ', error); } }); } uploadAttendeeFile(req, res, id) { return __awaiter(this, void 0, void 0, function* () { if (!id.match(/a[\\w\\d]{14,17}/)) return this.handleError(res, 'Error in WorkshopsController.uploadAttendeeFile(): ', { error: 'INVALID_SF_ID', message: `${id} is not a valid Salesforce ID.` }, common_1.HttpStatus.BAD_REQUEST); if (!req.attendeeList) return this.handleError(res, 'Error in WorkshopsController.uploadAttendeeFile(): ', { error: 'MISSING_FILEDS', fields: ['attendeeList'] }); const upload = multer({ storage: multer.memoryStorage(), limits: { fileSize: 1000 * 1000 * 25 } }).single('attendeeList'); return upload(req, res, error =&gt; { if (error) return this.handleError(res, 'Error in WorkshopsController.uploadAttendeeFile(): ', error); const ext = req.file.originalName.split('.').pop(); console.log('File Upload: ', req.file); console.log('File Base64: ', req.file.buffer.toString('base64')); console.log('File extension: ', ext); try { this.workshopsService.upload(id, `attendee_list.${ext}`, [req.file.buffer.toString('base64')]); } catch (error) { return this.handleError(res, 'Error in WorkshopsController.uploadAttendeeFile(): ', error); } return res.status(common_1.HttpStatus.ACCEPTED).json(); }); }); } uploadEvaluations(req, res, id) { return __awaiter(this, void 0, void 0, function* () { if (!id.match(/a[\\w\\d]{14,17}/)) return this.handleError(res, 'Error in WorkshopsController.uploadEvaluations(): ', { error: 'INVALID_SF_ID', message: `${id} is not a valid Salesforce ID.` }, common_1.HttpStatus.BAD_REQUEST); if (!req.evaluationFiles || !req.evaluationFiles.length) return this.handleError(res, 'Error in WorkshopsController.uploadEvaluations(): ', { error: 'MISSING_FILEDS', fields: ['evaluationFiles'] }); const upload = multer({ storage: multer.memoryStorage(), limits: { fileSize: 1000 * 1000 * 25, files: 30 } }).files('evaluationFiles'); return upload(req, res, error =&gt; { if (error) return this.handleError(res, 'Error in WorkshopsController.uploadEvaluations(): ', error); const files = req.files.map(file =&gt; { return file.buffer.toString('base64'); }); const ext = req.files[0].originalName.split('.').pop(); console.log('Files Upload: ', req.files); console.log('Files Base64: ', files); console.log('File extension: ', ext); try { this.workshopsService.upload(id, `attendee_list.${ext}`, files); } catch (error) { return this.handleError(res, 'Error in WorkshopsController.uploadEvaluations(): ', error); } return res.status(common_1.HttpStatus.ACCEPTED).json(); }); }); } /** * @desc &lt;h5&gt;DELETE: /workshops/&lt;em&gt;:id&lt;/eM&gt;&lt;/h5&gt; Calls {@link WorkshopsService#delete} to delete the workshop given by &lt;em&gt;:id&lt;/em&gt; * * @param {SalesforceId} id - Workshop\\__c id. match &lt;code&gt;/a[\\w\\d]{14,17}/&lt;/code&gt; * @returns {Promise&lt;Response&gt;} Response is a JSON Object from the resulting Salesforce operation * @memberof WorkshopsController */ delete(res, id) { return __awaiter(this, void 0, void 0, function* () { // Check the id if (!id.match(/a[\\w\\d]{14,17}/)) return this.handleError(res, 'Error in WorkshopsController.delete(): ', { error: 'INVALID_SF_ID', message: `${id} is not a valid Salesforce ID.` }, common_1.HttpStatus.BAD_REQUEST); try { const result = yield this.workshopsService.delete(id); return res.status(common_1.HttpStatus.OK).json(result); } catch (error) { return this.handleError(res, 'Error in WorkshopsController.delete(): ', error); } }); } }; __decorate([ common_1.Get(), __param(0, common_1.Response()), __param(1, common_1.Session()), __param(2, common_1.Query('isPublic')), __param(3, common_1.Headers('x-is-public')), __param(4, common_1.Headers('x-force-refresh')), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object, Object, Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], WorkshopsController.prototype, &quot;readAll&quot;, null); __decorate([ common_1.Get('/describe'), __param(0, common_1.Response()), __param(1, common_1.Headers('x-force-refresh')), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], WorkshopsController.prototype, &quot;describe&quot;, null); __decorate([ common_1.Get('/search'), __param(0, common_1.Response()), __param(1, common_1.Headers('x-search')), __param(2, common_1.Headers('x-retrieve')), __param(3, common_1.Headers('x-force-refresh')), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object, Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], WorkshopsController.prototype, &quot;search&quot;, null); __decorate([ common_1.Get('/:id'), __param(0, common_1.Response()), __param(1, common_1.Param('id')), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], WorkshopsController.prototype, &quot;read&quot;, null); __decorate([ common_1.Get('/:id/facilitators'), __param(0, common_1.Response()), __param(1, common_1.Param('id')), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], WorkshopsController.prototype, &quot;facilitators&quot;, null); __decorate([ common_1.Post(), __param(0, common_1.Response()), __param(1, common_1.Body()), __param(2, common_1.Session()), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], WorkshopsController.prototype, &quot;create&quot;, null); __decorate([ common_1.Put('/:id'), __param(0, common_1.Response()), __param(1, common_1.Param('id')), __param(2, common_1.Body()), __param(3, common_1.Session()), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object, Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], WorkshopsController.prototype, &quot;update&quot;, null); __decorate([ common_1.Post('/:id/attendee_file'), __param(0, common_1.Request()), __param(1, common_1.Response()), __param(2, common_1.Param('id')), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], WorkshopsController.prototype, &quot;uploadAttendeeFile&quot;, null); __decorate([ common_1.Post('/:id/attendee_file'), __param(0, common_1.Request()), __param(1, common_1.Response()), __param(2, common_1.Param('id')), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], WorkshopsController.prototype, &quot;uploadEvaluations&quot;, null); __decorate([ common_1.Delete('/:id'), __param(0, common_1.Response()), __param(1, common_1.Param('id')), __metadata(&quot;design:type&quot;, Function), __metadata(&quot;design:paramtypes&quot;, [Object, Object]), __metadata(&quot;design:returntype&quot;, Promise) ], WorkshopsController.prototype, &quot;delete&quot;, null); WorkshopsController = __decorate([ common_1.Controller('workshops'), __metadata(&quot;design:paramtypes&quot;, [components_1.WorkshopsService, components_1.LoggerService]) ], WorkshopsController); exports.WorkshopsController = WorkshopsController; × Search results Close "},"components_workshops_workshops.component.js.html":{"id":"components_workshops_workshops.component.js.html","title":"Source: components/workshops/workshops.component.js","body":" Shingo Affiliate Portal Classes AffiliatesControllerAffiliatesServiceAuthControllerAuthServiceBaseControllerCacheServiceFacilitatorsControllerFacilitatorsServiceSalesforceServiceUserServiceWorkshopsControllerWorkshopsService Source: components/workshops/workshops.component.js &quot;use strict&quot;; var __decorate = (this &amp;&amp; this.__decorate) || function (decorators, target, key, desc) { var c = arguments.length, r = c &lt; 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d; if (typeof Reflect === &quot;object&quot; &amp;&amp; typeof Reflect.decorate === &quot;function&quot;) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i &gt;= 0; i--) if (d = decorators[i]) r = (c &lt; 3 ? d(r) : c &gt; 3 ? d(target, key, r) : d(target, key)) || r; return c &gt; 3 &amp;&amp; r &amp;&amp; Object.defineProperty(target, key, r), r; }; var __metadata = (this &amp;&amp; this.__metadata) || function (k, v) { if (typeof Reflect === &quot;object&quot; &amp;&amp; typeof Reflect.metadata === &quot;function&quot;) return Reflect.metadata(k, v); }; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const common_1 = require(&quot;@nestjs/common&quot;); const _1 = require(&quot;../&quot;); const lodash_1 = require(&quot;lodash&quot;); /** * @desc A service to provide functions for working with Workshops * * @export * @class WorkshopsService */ let WorkshopsService = class WorkshopsService { constructor() { this.sfService = new _1.SalesforceService(); this.authService = new _1.AuthService(); this.cache = new _1.CacheService(); this.userService = new _1.UserService(); } /** * @desc Get all workshops that the current session's user has permissions for (or all publicly listed workshps). The function assembles a list of workshop ids form the users permissions to query Salesforce. The queried fields from Salesforce are as follows:&lt;br&gt;&lt;br&gt; * &lt;code&gt;[&lt;br&gt; * &amp;emsp;&quot;Id&quot;,&lt;br&gt; * &amp;emsp;&quot;Name&quot;,&lt;br&gt; * &amp;emsp;&quot;Start_Date\\__c&quot;,&lt;br&gt; * &amp;emsp;&quot;End_Date\\__c&quot;,&lt;br&gt; * &amp;emsp;&quot;Course_Manager\\__c&quot;,&lt;br&gt; * &amp;emsp;&quot;Billing_Contact\\__c&quot;,&lt;br&gt; * &amp;emsp;&quot;Event_City\\__c&quot;,&lt;br&gt; * &amp;emsp;&quot;Event_Country\\__c&quot;,&lt;br&gt; * &amp;emsp;&quot;Organizing_Affiliate\\__c&quot;,&lt;br&gt; * &amp;emsp;&quot;Public\\__c&quot;,&lt;br&gt; * &amp;emsp;&quot;Registration_Website\\__c&quot;,&lt;br&gt; * &amp;emsp;&quot;Status\\__c&quot;,&lt;br&gt; * &amp;emsp;&quot;Host_Site\\__c&quot;,&lt;br&gt; * &amp;emsp;&quot;Workshop_Type\\__c&quot;,&lt;br&gt; * &amp;emsp;&quot;Language\\__c&quot;&lt;br&gt; * ]&lt;/code&gt;&lt;br&gt;&lt;br&gt; * The query is ordered by &lt;em&gt;'Start_Date\\__c'&lt;/em&gt;. * * @param {boolean} [isPublic=false] - Get Only public workshops (skips permission check) * @param {boolean} [refresh=false] - Force the refresh of the cache * @param {any} [user] - The user to filter permissions for (&lt;code&gt;isPublic === false&lt;/code&gt;); user needs permissions[] and roles[].permissions[] * @returns {Promise&lt;Workshop[]&gt;} * @memberof WorkshopsService */ getAll(isPublic = false, refresh = false, user) { return __awaiter(this, void 0, void 0, function* () { const query = { action: 'SELECT', fields: [ &quot;Id&quot;, &quot;Name&quot;, &quot;Start_Date__c&quot;, &quot;End_Date__c&quot;, &quot;Course_Manager__c&quot;, &quot;Billing_Contact__c&quot;, &quot;Event_City__c&quot;, &quot;Event_Country__c&quot;, &quot;Organizing_Affiliate__c&quot;, &quot;Public__c&quot;, &quot;Registration_Website__c&quot;, &quot;Status__c&quot;, &quot;Host_Site__c&quot;, &quot;Workshop_Type__c&quot;, &quot;Language__c&quot; ], table: &quot;Workshop__c&quot;, clauses: &quot;Public__c=true AND Status__c='Verified' ORDER BY Start_Date__c&quot; }; if (!isPublic) { const ids = this.userService.getWorkshopIds(user); if (ids.length === 0) return Promise.resolve([]); query.clauses = `Id IN (${ids.join()}) ORDER BY Start_Date__c`; } if (!this.cache.isCached(query) || refresh) { let workshops = (yield this.sfService.query(query)).records; if (isPublic) this.cache.cache(query, workshops); return Promise.resolve(workshops); } else { return Promise.resolve(this.cache.getCache(query)); } }); } /** * @desc Get a specific workshop by Salesforce ID. Retrieves all fields of the Workshop\\__c object. Specifically:&lt;br&gt;&lt;br&gt; * &lt;code&gt;[&lt;br&gt; * &amp;emsp;&quot;Id&quot;,&lt;br&gt; * &amp;emsp;&quot;IsDeleted&quot; ,&lt;br&gt; * &amp;emsp;&quot;Name&quot;,&lt;br&gt; * &amp;emsp;&quot;CreatedDate&quot;,&lt;br&gt; * &amp;emsp;&quot;CreatedById&quot;,&lt;br&gt; * &amp;emsp;&quot;LastModifiedDate&quot;,&lt;br&gt; * &amp;emsp;&quot;LastModifiedById&quot;,&lt;br&gt; * &amp;emsp;&quot;SystemModstamp&quot;,&lt;br&gt; * &amp;emsp;&quot;LastViewedDate&quot;,&lt;br&gt; * &amp;emsp;&quot;LastReferencedDate&quot;,&lt;br&gt; * &amp;emsp;&quot;Billing_Contact\\__c&quot;,&lt;br&gt; * &amp;emsp;&quot;Course_Manager\\__c&quot;,&lt;br&gt; * &amp;emsp;&quot;End_Date\\__c&quot;,&lt;br&gt; * &amp;emsp;&quot;Event_City\\__c&quot;,&lt;br&gt; * &amp;emsp;&quot;Event_Country\\__c&quot;,&lt;br&gt; * &amp;emsp;&quot;Organizing_Affiliate\\__c&quot;,&lt;br&gt; * &amp;emsp;&quot;Public\\__c&quot;,&lt;br&gt; * &amp;emsp;&quot;Registration_Website\\__c&quot;,&lt;br&gt; * &amp;emsp;&quot;Start_Date\\__c&quot;,&lt;br&gt; * &amp;emsp;&quot;Status\\__c&quot;,&lt;br&gt; * &amp;emsp;&quot;Workshop_Type\\__c&quot;,&lt;br&gt; * &amp;emsp;&quot;Host_Site\\__c&quot;,&lt;br&gt; * &amp;emsp;&quot;Language\\__c&quot;,&lt;br&gt; * ]&lt;/code&gt; * * @param {string} id - A Salesforce ID corresponding to a Workshop\\__c record * @returns {Promise&lt;Workshop&gt;} * @memberof WorkshopsService */ get(id) { return __awaiter(this, void 0, void 0, function* () { // Create the data parameter for the RPC call let workshop = (yield this.sfService.retrieve({ object: 'Workshop__c', ids: [id] })); workshop.facilitators = yield this.facilitators(id); return Promise.resolve(workshop); }); } /** * @desc Uses the Salesforce REST API to describe the Workshop\\__c object. See the Salesforce documentation for more about 'describe'. * * @param {boolean} [refresh=false] - Force the refresh of the cache * @returns {Promise&lt;any&gt;} * @memberof WorkshopsService */ describe(refresh = false) { return __awaiter(this, void 0, void 0, function* () { // Set the key for the cache const key = 'describeWorkshops'; // If no cached result, use the shingo-sf-api to get the result if (!this.cache.isCached(key) || refresh) { const describeObject = yield this.sfService.describe('Workshop__c'); // Cache describe this.cache.cache(key, describeObject); return Promise.resolve(describeObject); } else { return Promise.resolve(this.cache.getCache(key)); } }); } /** * @desc Executes a SOSL query to search for text on workshop records in Salesforce. Example response body:&lt;br&gt;&lt;br&gt; * &lt;code&gt;[&lt;br&gt; * &amp;emsp;{&lt;br&gt; * &amp;emsp;&amp;emsp;&quot;Id&quot;: &quot;a1Sg0000001jXbgEAE&quot;,&lt;br&gt; * &amp;emsp;&amp;emsp;&quot;Name&quot;: &quot;Test Workshop 10 (Updated)&quot;,&lt;br&gt; * &amp;emsp;&amp;emsp;&quot;Start_Date\\__c&quot;: &quot;2017-07-12&quot;&lt;br&gt; * &amp;emsp;},&lt;br&gt; * &amp;emsp;{&lt;br&gt; * &amp;emsp;&amp;emsp;&quot;Id&quot;: &quot;a1Sg0000001jXWgEAM&quot;,&lt;br&gt; * &amp;emsp;&amp;emsp;&quot;Name&quot;: &quot;Test Workshop 9 (Updated)&quot;,&lt;br&gt; * &amp;emsp;&amp;emsp;&quot;Start_Date\\__c&quot;: &quot;2017-07-11&quot;&lt;br&gt; * &amp;emsp;},&lt;br&gt; * &amp;emsp;{&lt;br&gt; * &amp;emsp;&amp;emsp;&quot;Id&quot;: &quot;a1Sg0000001jXWbEAM&quot;,&lt;br&gt; * &amp;emsp;&amp;emsp;&quot;Name&quot;: &quot;Test Workshop 8&quot;,&lt;br&gt; * &amp;emsp;&amp;emsp;&quot;Start_Date\\__c&quot;: &quot;2017-07-11&quot;&lt;br&gt; * &amp;emsp;}&lt;br&gt; * ]&lt;/code&gt; * * @param {Header} search - SOSL search expression (i.e. '*Discover Test*') * @param {Header} retrieve - A comma seperated list of the Workshop\\__c fields to retrieve (i.e. 'Id, Name, Start_Date\\__c') * @param {Header} [refresh='false'] - Used to force the refresh of the cache * @returns {Promise&lt;Workshop[]&gt;} * @memberof WorkshopsService */ search(search, retrieve, refresh = false) { return __awaiter(this, void 0, void 0, function* () { // Generate the data parameter for the RPC call const data = { search: `{${search}}`, retrieve: `Workshop__c(${retrieve})` }; // If no cached result, use the shingo-sf-api to get result if (!this.cache.isCached(data) || refresh) { const workshops = (yield this.sfService.search(data)).searchRecords || []; // Cache results this.cache.cache(data, workshops); return Promise.resolve(workshops); } else { return Promise.resolve(this.cache.getCache(data)); } }); } /** * @desc Get the associated instructors for the workshop with id given in the param &lt;em&gt;:id&lt;/em&gt;. Queried fields are as follows:&lt;br&gt;&lt;br&gt; * &lt;code&gt;[&lt;br&gt; * &amp;emsp;&quot;Instructor\\__r.FirstName&quot;,&lt;br&gt; * &amp;emsp;&quot;Instructor\\__r.LastName&quot;,&lt;br&gt; * &amp;emsp;&quot;Instructor\\__r.Email&quot;,&lt;br&gt; * &amp;emsp;&quot;Instructor\\__r.Title&quot;&lt;br&gt; * ]&lt;/code&gt; * * @param {string} id - A Salesforce ID corresponding to a Workshop\\__c record * @returns {Promise&lt;object[]&gt;} * @memberof WorkshopsService */ facilitators(id) { return __awaiter(this, void 0, void 0, function* () { let query = { action: &quot;SELECT&quot;, fields: [ &quot;Id&quot;, &quot;Instructor__r.Id&quot;, &quot;Instructor__r.FirstName&quot;, &quot;Instructor__r.LastName&quot;, &quot;Instructor__r.Email&quot;, &quot;Instructor__r.Title&quot; ], table: &quot;WorkshopFacilitatorAssociation__c&quot;, clauses: `Workshop__c='${id}'` }; const facilitators = (yield this.sfService.query(query)).records || []; return Promise.resolve(facilitators); }); } /** * @desc Creates a new workshop in Salesforce and creates permissions for the workshop in the Shingo Auth API. Returns the following:&lt;br&gt;&lt;br&gt; * &lt;code&gt;{&lt;br&gt; * &amp;emsp;&quot;id&quot;: SalesforceId,&lt;br&gt; * &amp;emsp;&quot;success&quot;: boolean,&lt;br&gt; * &amp;emsp;&quot;errors&quot;: []&lt;br&gt; * }&lt;/code&gt; * * @param {Workshop} workshop - The workshop to be created. Requires &lt;code&gt;[ 'Name', 'Start_Date\\__c', 'End_Date\\__c', 'Organizing_Affiliate\\__c' ] * @returns {Promise&lt;any&gt;} * @memberof WorkshopsService */ create(workshop) { return __awaiter(this, void 0, void 0, function* () { // Use the shingo-sf-api to create the new record const data = { object: 'Workshop__c', records: [{ contents: JSON.stringify(lodash_1._.omit(workshop, ['facilitators'])) }] }; const result = (yield this.sfService.create(data))[0]; workshop.Id = result.id; yield this.grantPermissions(workshop); return Promise.resolve(result); }); } /** * @desc Updates a workshop's fields. This function also will get the instructor associations with the given workshop to update associations and permissions. Returns the following:&lt;br&gt;&lt;br&gt; * &lt;code&gt;{&lt;br&gt; * &amp;emsp;&quot;id&quot;: SalesforceId,&lt;br&gt; * &amp;emsp;&quot;success&quot;: boolean,&lt;br&gt; * &amp;emsp;&quot;errors&quot;: []&lt;br&gt; * }&lt;/code&gt; * * @param {Workshop} workshop * @returns {Promise&lt;any&gt;} * @memberof WorkshopsService */ update(workshop) { return __awaiter(this, void 0, void 0, function* () { // Use the shingo-sf-api to create the new record const data = { object: 'Workshop__c', records: [{ contents: JSON.stringify(lodash_1._.omit(workshop, ['facilitators'])) }] }; const result = (yield this.sfService.update(data))[0]; const currFacilitators = yield this.facilitators(workshop.Id); const removeFacilitators = lodash_1._.differenceWith(currFacilitators, workshop.facilitators, (val, other) =&gt; { return other &amp;&amp; val.Instructor__r.Id === other.Id; }); workshop.facilitators = lodash_1._.differenceWith(workshop.facilitators, currFacilitators, (val, other) =&gt; { return other &amp;&amp; val.Id === other.Instructor__r.Id; }); yield this.grantPermissions(workshop); yield this.removePermissions(workshop, removeFacilitators); return Promise.resolve(result); }); } upload(id, fileName, files) { return __awaiter(this, void 0, void 0, function* () { const records = []; let fileId = 0; for (const file of files) { records.push({ contents: JSON.stringify({ ParentId: id, Name: `${fileId++}-${fileName}`, Body: file }) }); } const data = { object: 'Attachment', records }; const result = yield this.sfService.create(data); return Promise.resolve(result); }); } /** * @desc Deletes the workshop given by &lt;em&gt;:id&lt;/em&gt; in Salesforce and removes the permission in the Auth API. Returns the following:&lt;br&gt;&lt;br&gt; * &lt;code&gt;{&lt;br&gt; * &amp;emsp;&quot;id&quot;: SalesforceId,&lt;br&gt; * &amp;emsp;&quot;success&quot;: boolean,&lt;br&gt; * &amp;emsp;&quot;errors&quot;: []&lt;br&gt; * }&lt;/code&gt; * * @param {string} id * @returns {Promise&lt;any&gt;} * @memberof WorkshopsService */ delete(id) { return __awaiter(this, void 0, void 0, function* () { // Create the data parameter for the RPC call const data = { object: 'Workshop__c', ids: [id] }; const result = (yield this.sfService.delete(data))[0]; for (const level of [0, 1, 2]) yield this.authService.deletePermission(`/workshops/${id}`, level); return Promise.resolve(result); }); } /** * @desc Helper method to grant permissions to the appropraite roles and users in the Auth API. * * @private * @param {Workshop} workshop - Requires [ 'Id', 'facilitators' ] * @returns {Promise&lt;void&gt;} * @memberof WorkshopsService */ grantPermissions(workshop) { return __awaiter(this, void 0, void 0, function* () { const roles = (yield this.authService.getRoles(`role.name=\\'Affiliate Manager\\' OR role.name='Course Manager -- ${workshop.Organizing_Affiliate__c}'`)).roles; const resource = `/workshops/${workshop.Id}`; for (const role of roles) { yield this.authService.grantPermissionToRole(resource, 2, role.id); } for (const facilitator of workshop.facilitators) { const data = { object: 'WorkshopFacilitatorAssociation__c', records: [{ contents: JSON.stringify({ Workshop__c: workshop.Id, Instructor__c: facilitator['Id'] }) }] }; yield this.sfService.create(data); yield this.authService.grantPermissionToUser(resource, 2, facilitator['id']); } return Promise.resolve(); }); } /** * @desc Helper method to remove permissions from deleted facilitators * * @private * @param {Workshop} workshop - Requires [ 'Id', 'facilitators' ] * @param {any[]} remove - Requires [ 'Instructor__r'.'Id' ] * @returns {Promise&lt;void&gt;} * @memberof WorkshopsService */ removePermissions(workshop, remove) { return __awaiter(this, void 0, void 0, function* () { const resource = `/workshops/${workshop.Id}`; const ids = remove.map(facilitator =&gt; { return facilitator.Id; }); yield this.sfService.delete({ object: 'WorkshopFacilitatorAssociation__c', ids }); const emails = remove.map(facilitator =&gt; { return `'${facilitator.Instructor__r.Email}'`; }); if (!emails.length) return Promise.resolve(); const users = yield this.authService.getUsers(`user.email IN (${emails.join()})`); for (const user in users) { yield this.authService.revokePermissionFromUser(resource, 2, user['id']); } return Promise.resolve(); }); } }; WorkshopsService = __decorate([ common_1.Component(), __metadata(&quot;design:paramtypes&quot;, []) ], WorkshopsService); exports.WorkshopsService = WorkshopsService; × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Shingo Affiliate Portal Classes AffiliatesControllerAffiliatesServiceAuthControllerAuthServiceBaseControllerCacheServiceFacilitatorsControllerFacilitatorsServiceSalesforceServiceUserServiceWorkshopsControllerWorkshopsService Classes Classes AffiliatesController AffiliatesService AuthController AuthService BaseController CacheService FacilitatorsController FacilitatorsService SalesforceService UserService WorkshopsController WorkshopsService × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Shingo Affiliate Portal Classes AffiliatesControllerAffiliatesServiceAuthControllerAuthServiceBaseControllerCacheServiceFacilitatorsControllerFacilitatorsServiceSalesforceServiceUserServiceWorkshopsControllerWorkshopsService Shingo Affiliate Portal APIIntroductionThis project aims to provide REST services to the Shingo Affiliate Portal. Services provided are authentication, CRUD operations for Workhops, CRUD operations for Facilitators, and CRUD operations for Affiliates. External DepedanciesThe Shingo Affiliate Portal API consumes the Shingo SF Microservice and the Shingo Auth Microservice. ReferenceWorkshops GET: /workshops GET: /workshops/:id GET: /workshops/:id/facilitators GET: /workshops/describe GET: /workshops/search POST: /workshops PUT: /workshops/:id DELETE: /workshops/:id Facilitators GET: /facilitators GET: /facilitators/:id GET: /facilitators/describe GET: /facilitators/search POST: /facilitators POST: /facilitators/:id/roles/:roleId PUT: /facilitators/:id DELETE: /facilitators/:id DELETE: /facilitators/:id/login DELETE: /facilitators/:id/unamp Affiliates GET: /affiliates GET: /affiliates/:id GET: /affiliates/describe GET: /affiliates/search POST: /affiliates POST: /affiliates/:id/map PUT: /affiliates/:id DELETE: /affiliates/:id Auth POST: /auth/login GET: /auth/logout × Search results Close "},"AffiliatesController.html":{"id":"AffiliatesController.html","title":"Class: AffiliatesController","body":" Shingo Affiliate Portal Classes AffiliatesControllerAffiliatesServiceAuthControllerAuthServiceBaseControllerCacheServiceFacilitatorsControllerFacilitatorsServiceSalesforceServiceUserServiceWorkshopsControllerWorkshopsService Class: AffiliatesController AffiliatesController new AffiliatesController() Controller of the REST API logic for Affiliates Source: controllers/affiliates/affiliates.controller.js, line 27 Extends BaseController Methods create(body) POST: /affiliates Calls AffiliatesService#create to create a new Affiliate Parameters: Name Type Description body Body Required fields [ &quot;Name&quot; ] Source: controllers/affiliates/affiliates.controller.js, line 130 Returns: Type Promise.&lt;Response&gt; delete(id) DELETE: /affiliates/:id Calls AffiliatesService#delete to delete an Affiliate Parameters: Name Type Description id SalesforceId Account id. match /[\\w\\d]{15,17}/ Source: controllers/affiliates/affiliates.controller.js, line 195 Returns: Type Promise.&lt;Response&gt; describe( [refresh]) GET: /affiliates/describe Calls AffiliatesService#describe to describe the Account Object Parameters: Name Type Argument Default Description refresh Header &lt;optional&gt; 'false' Header 'x-force-refresh'; Expected values [ 'true', 'false' ]; Forces cache refresh Source: controllers/affiliates/affiliates.controller.js, line 69 Returns: Type Promise.&lt;Response&gt; &lt;protected&gt; handleError(res, message, error [, errorCode]) A helper function to return an error response to the client. Parameters: Name Type Argument Default Description res Response The express response from the calling route message string Log message error * An error object to be logged and returned as JSON errorCode HttpStatus &lt;optional&gt; HttpStatus.INTERNAL_SERVER_ERROR HttpStatus CODE Inherited From: BaseController#handleError Source: controllers/base.controller.js, line 35 Returns: Response body is a JSON object with the error map(id) POST: /affiliates/:id/map Calls AffiliatesService#map to create permissions for a Licensed Affiliate Account Parameters: Name Type Description id SalesforceId Account id. match /[\\w\\d]{15,17}/ Source: controllers/affiliates/affiliates.controller.js, line 151 Returns: Type Promise.&lt;Response&gt; read(id) GET: /affiliates/:id Calls AffiliatesService#get to retrieve a specific affiliate Parameters: Name Type Description id SalesforceId Account id. match /[\\w\\d]{15,17}/ Source: controllers/affiliates/affiliates.controller.js, line 110 Returns: Type Promise.&lt;Response&gt; readAll(isPublicQ, isPublicH [, refresh]) GET: /affiliates Calls AffiliatesService#getAll to get a list of affiliates Parameters: Name Type Argument Default Description isPublicQ Query Query parameter 'isPublic'; Expected values [ 'true', 'false' ]; Alias headers['x-force-refesh']; Returns public affiliates isPublicH Header Header 'x-is-public'; Expected values [ 'true', 'false' ]; Alias query['isPublic']; Returns public affiliates refresh Header &lt;optional&gt; 'false' Header 'x-force-refresh'; Expected values [ 'true', 'false' ]; Forces cache refresh Source: controllers/affiliates/affiliates.controller.js, line 49 Returns: Type Promise.&lt;Response&gt; search(search, retrieve [, refresh]) GET: /affiliates/search Calls AffiliatesService#search. Returns an array of affiliates that match search criteria Parameters: Name Type Argument Default Description search Header Header 'x-search'. SOSL search expression (i.e. 'Test'). retrieve Header Header 'x-retrieve'. A comma seperated list of the Account fields to retrieve (i.e. 'Id, Name') refresh Header &lt;optional&gt; 'false' Header 'x-force-refresh'; Expected values [ 'true', 'false' ]; Forces cache refresh Source: controllers/affiliates/affiliates.controller.js, line 89 Returns: Type Promise.&lt;Response&gt; update(body, id) PUT: /affiliates/:id Calls AffiliatesService#update to update an Affiliate Parameters: Name Type Description body Body Required fields [ &quot;Id&quot; ] id SalesforceId Account id. match /[\\w\\d]{15,17}/ Source: controllers/affiliates/affiliates.controller.js, line 172 Returns: Type Promise.&lt;Response&gt; × Search results Close "},"AffiliatesService.html":{"id":"AffiliatesService.html","title":"Class: AffiliatesService","body":" Shingo Affiliate Portal Classes AffiliatesControllerAffiliatesServiceAuthControllerAuthServiceBaseControllerCacheServiceFacilitatorsControllerFacilitatorsServiceSalesforceServiceUserServiceWorkshopsControllerWorkshopsService Class: AffiliatesService AffiliatesService new AffiliatesService() A service to provide functions for working with Affiliates Source: components/affiliates/affiliates.component.js, line 22 Methods create(affiliate) Creates a new Account of record type 'Licensed Affiliate' in Salesforce and corresponding permissions and roles. Returns the following: { &quot;id&quot;: SalesforceId, &quot;success&quot;: boolean, &quot;errors&quot;: [] } Parameters: Name Type Description affiliate Affiliate Affiliate to create Source: components/affiliates/affiliates.component.js, line 177 Returns: Type Promise.&lt;any&gt; delete(id) Deletes an Affiliate. Returns the following: { &quot;id&quot;: SalesforceId, &quot;success&quot;: boolean, &quot;errors&quot;: [] } Parameters: Name Type Description id string Salesforce Id of the Account to delete Source: components/affiliates/affiliates.component.js, line 244 Returns: Type Promise.&lt;any&gt; describe( [refresh]) Uses the Salesforce REST API to describe the Account object. See the Salesforce documentation for more about 'describe' Parameters: Name Type Argument Default Description refresh boolean &lt;optional&gt; false Force the refresh of the cache Source: components/affiliates/affiliates.component.js, line 104 Returns: Type Promise.&lt;any&gt; get(id) Get the facilitator with the id passed at the parameter :id. The following fields are returned: [ TODO: Add fields that are returned ] Parameters: Name Type Description id string Salesforce ID for an Account Source: components/affiliates/affiliates.component.js, line 91 Returns: Type Promise.&lt;Affiliate&gt; getAll( [isPublic] [, refresh]) Get all AFfiliates (minus McKinsey if isPublic). Queries the following fields: [ &quot;Id&quot;, &quot;Name&quot;, &quot;Summaryc&quot;, &quot;Logoc&quot;, &quot;Page_Pathc&quot;, &quot;Website&quot;, &quot;Languagesc&quot; ] Parameters: Name Type Argument Default Description isPublic boolean &lt;optional&gt; false Filter out private Affiliates refresh boolean &lt;optional&gt; false Force the refresh of the cache Source: components/affiliates/affiliates.component.js, line 52 Returns: Type Promise.&lt;Array.&lt;Affiliate&gt;&gt; map(id) Create the corresponding permissions and roles for the Affiliate in the Shingo Auth API. Parameters: Name Type Description id string Affiliate's Account Id Source: components/affiliates/affiliates.component.js, line 197 Returns: Type Promise.&lt;any&gt; search(search, retrieve [, refresh]) Executes a SOSL query to search for text on Accounts of record type Licensed Affiliate. Example response body: [ { &quot;Id&quot;: &quot;003g000001VvwEZAAZ&quot;, &quot;Name&quot;: &quot;Test One&quot;, }, { &quot;Id&quot;: &quot;003g000001VvwEZABA&quot;, &quot;Name&quot;: &quot;Test Two&quot;, }, { &quot;Id&quot;: &quot;003g000001VvwEZABB&quot;, &quot;Name&quot;: &quot;Test Three&quot;, }, ] Parameters: Name Type Argument Default Description search Header Header 'x-search'. SOSL search expression (i.e. 'Test'). retrieve Header Header 'x-retrieve'. A comma seperated list of the Account fields to retrieve (i.e. 'Id, Name') refresh boolean &lt;optional&gt; false Force the refresh of the cache Source: components/affiliates/affiliates.component.js, line 143 Returns: Type Promise.&lt;Array.&lt;Affiliate&gt;&gt; update(affiliate) Updates an Affiliate's fields: Returns the following: { &quot;id&quot;: SalesforceId, &quot;success&quot;: boolean, &quot;errors&quot;: [] } Parameters: Name Type Description affiliate Affiliate Affiliate's fields to update Source: components/affiliates/affiliates.component.js, line 221 Returns: Type Promise.&lt;any&gt; × Search results Close "},"AuthController.html":{"id":"AuthController.html","title":"Class: AuthController","body":" Shingo Affiliate Portal Classes AffiliatesControllerAffiliatesServiceAuthControllerAuthServiceBaseControllerCacheServiceFacilitatorsControllerFacilitatorsServiceSalesforceServiceUserServiceWorkshopsControllerWorkshopsService Class: AuthController AuthController new AuthController() Provides the controller of the Auth REST logic Source: controllers/auth/auth.controller.js, line 27 Extends BaseController Methods async() GET: /auth/valid Protected by isValid middleware. Only get called if the value of x-jwt corresponds to a valid user Source: controllers/auth/auth.controller.js, line 88 Returns: Type Promise.&lt;Response&gt; &lt;protected&gt; handleError(res, message, error [, errorCode]) A helper function to return an error response to the client. Parameters: Name Type Argument Default Description res Response The express response from the calling route message string Log message error * An error object to be logged and returned as JSON errorCode HttpStatus &lt;optional&gt; HttpStatus.INTERNAL_SERVER_ERROR HttpStatus CODE Inherited From: BaseController#handleError Source: controllers/base.controller.js, line 35 Returns: Response body is a JSON object with the error login(body) POST: /auth/login Calls AuthService#login and SalesforceService#query to login a user Parameters: Name Type Description body any Required fields: [ 'email', 'password' ] Source: controllers/auth/auth.controller.js, line 48 Returns: Response body is an object with the user's JWT Type Promise.&lt;Response&gt; logout() GET: /auth/logout Calls AuthService#updateUser to set the user's JWT to '' and removes the user from the session Source: controllers/auth/auth.controller.js, line 97 Returns: Type Promise.&lt;Response&gt; × Search results Close "},"AuthService.html":{"id":"AuthService.html","title":"Class: AuthService","body":" Shingo Affiliate Portal Classes AffiliatesControllerAffiliatesServiceAuthControllerAuthServiceBaseControllerCacheServiceFacilitatorsControllerFacilitatorsServiceSalesforceServiceUserServiceWorkshopsControllerWorkshopsService Class: AuthService AuthService new AuthService() A service to abastract the Shingo Auth Microservice client Source: components/auth/auth.component.js, line 17 Methods parseRPCErrorMeta(error) Utility method to assist in parsing gRPC error metadata. Returns a JSON object from the parsed error data. If no JSON object can be parsed, the method attempts to return the 'error-bin' from the meta-data as a string. If that fails the method returns the error passed to it. Parameters: Name Type Description error gRPCError The error to be parsed Source: components/auth/auth.component.js, line 116 Returns: The parsed error, 'error-bin'.toString(), or passed in error Type object × Search results Close "},"BaseController.html":{"id":"BaseController.html","title":"Class: BaseController","body":" Shingo Affiliate Portal Classes AffiliatesControllerAffiliatesServiceAuthControllerAuthServiceBaseControllerCacheServiceFacilitatorsControllerFacilitatorsServiceSalesforceServiceUserServiceWorkshopsControllerWorkshopsService Class: BaseController BaseController new BaseController() The base controller class contains methods shared between multiple routes Source: controllers/base.controller.js, line 17 Methods &lt;protected&gt; handleError(res, message, error [, errorCode]) A helper function to return an error response to the client. Parameters: Name Type Argument Default Description res Response The express response from the calling route message string Log message error * An error object to be logged and returned as JSON errorCode HttpStatus &lt;optional&gt; HttpStatus.INTERNAL_SERVER_ERROR HttpStatus CODE Source: controllers/base.controller.js, line 35 Returns: Response body is a JSON object with the error × Search results Close "},"CacheService.html":{"id":"CacheService.html","title":"Class: CacheService","body":" Shingo Affiliate Portal Classes AffiliatesControllerAffiliatesServiceAuthControllerAuthServiceBaseControllerCacheServiceFacilitatorsControllerFacilitatorsServiceSalesforceServiceUserServiceWorkshopsControllerWorkshopsService Class: CacheService CacheService new CacheService() A service that provides an in-memory cache Source: components/cache/cache.component.js, line 15 Methods cache(obj, value) Caches the value based on the resulting key. Logs error if not successfully. Parameters: Name Type Description obj object | string value * Source: components/cache/cache.component.js, line 69 getCache(obj) Get the cached result for the give key Parameters: Name Type Description obj object | string Source: components/cache/cache.component.js, line 43 Returns: The cached result. 'undefined' if key is not found. isCached(obj) Checks if cache contains key Parameters: Name Type Description obj object | string Source: components/cache/cache.component.js, line 56 Returns: Type boolean × Search results Close "},"FacilitatorsController.html":{"id":"FacilitatorsController.html","title":"Class: FacilitatorsController","body":" Shingo Affiliate Portal Classes AffiliatesControllerAffiliatesServiceAuthControllerAuthServiceBaseControllerCacheServiceFacilitatorsControllerFacilitatorsServiceSalesforceServiceUserServiceWorkshopsControllerWorkshopsService Class: FacilitatorsController FacilitatorsController new FacilitatorsController() Controller of the REST API logic for Facilitators Source: controllers/facilitators/facilitators.controller.js, line 28 Extends BaseController Methods changeRole(id, roleId) POST: /facilitators/:id/roles/:roleId Calls FacilitatorsService#changeRole to change a Facilitator's role Parameters: Name Type Description id SalesforceId Contact id. match /[\\w\\d]{15,17}/ roleId number Id of the role to change too Source: controllers/facilitators/facilitators.controller.js, line 257 Returns: Response body is result of add Type Promise.&lt;Response&gt; create(body) POST: /facilitators Calls FacilitatorsService#create to create a new Facilitator Parameters: Name Type Description body Body Required fields: [ 'AccountId', 'FirstName', 'LastName', 'Email', 'password' ]Optional fields: [ 'roleId' ] Source: controllers/facilitators/facilitators.controller.js, line 144 Returns: Response body is a JSON object. Type Promise.&lt;Response&gt; delete(id [, deleteAuth]) DELETE: /facilitators/:id Calls FacilitatorsService#delete, FacilitatorsService#deleteAuth or FacilitatorsService#unmapAuth to remove a facilitator from the affiliate portal Parameters: Name Type Argument Default Description id SalesforceId Contact id. match /[\\w\\d]{15,17}/ deleteAuth string &lt;optional&gt; 'true' Delete auth as well Source: controllers/facilitators/facilitators.controller.js, line 191 Returns: Response is status of deletes and resulting SF Operation Type Promise.&lt;Response&gt; deleteLogin(id) DELETE: /facilitators/:id/login Calls FacilitatorsService#deleteAuth to delete a Facilitator's login only Parameters: Name Type Description id SalesforceId Contact id. match /[\\w\\d]{15,17}/ Source: controllers/facilitators/facilitators.controller.js, line 216 Returns: Response body is result of delete Type Promise.&lt;Response&gt; describe( [refresh]) GET: /facilitators/describe Calls FacilitatorsService#describe to describe Contact Parameters: Name Type Argument Default Description refresh Header &lt;optional&gt; 'false' Header 'x-force-refresh'; Expected values [ 'true', 'false' ]; Forces cache refresh Source: controllers/facilitators/facilitators.controller.js, line 74 Returns: Response body is a JSON object with the describe result Type Promise.&lt;Response&gt; &lt;protected&gt; handleError(res, message, error [, errorCode]) A helper function to return an error response to the client. Parameters: Name Type Argument Default Description res Response The express response from the calling route message string Log message error * An error object to be logged and returned as JSON errorCode HttpStatus &lt;optional&gt; HttpStatus.INTERNAL_SERVER_ERROR HttpStatus CODE Inherited From: BaseController#handleError Source: controllers/base.controller.js, line 35 Returns: Response body is a JSON object with the error read(id) GET: /facilitators/:id Calls FacilitatorsService#get to retrieve a Facilitator Parameters: Name Type Description id SalesforceId Contact id. match /[\\w\\d]{15,17}/ Source: controllers/facilitators/facilitators.controller.js, line 123 Returns: Response body is a JSON object of type {returned fields} Type Promise.&lt;Response&gt; readAll( [xAffiliate] [, refresh]) GET: /facilitators Call FacilitatorsService#getAll to get a list of facilitators for given 'x-affiliate' || req.session.affilaite Parameters: Name Type Argument Default Description xAffiliate Header &lt;optional&gt; '' Header 'x-affiliate' Used by the 'Affiliate Manager' role to specify the affiliate to query facilitators for ('' queries all affiliates). refresh Header &lt;optional&gt; 'false' Header 'x-force-refresh'; Expected values [ 'true', 'false' ]; Forces cache refresh Source: controllers/facilitators/facilitators.controller.js, line 49 Returns: Response body is JSON Array of objects of type {queried fields} Type Promise.&lt;Response&gt; search(search, retrieve [, refresh]) GET: /facilitators/search Calls FacilitatorsService#search to search for facilitators Parameters: Name Type Argument Default Description search Header Header 'x-search'. SOSL search expression (i.e. 'Test') retrieve Header Header 'x-retrieve'. A comma seperated list of the Contact fields to retrieve (i.e. 'Id, Name, Email') refresh Header &lt;optional&gt; 'false' Header 'x-force-refresh'; Expected values [ 'true', 'false' ]; Forces cache refresh Source: controllers/facilitators/facilitators.controller.js, line 95 Returns: Response body is a JSON Array of objects of type {retrieve fields} Type Promise.&lt;Response&gt; unamp(id) DELETE: /facilitators/:id/unmap Calls FacilitatorsService#unmapAuth to remove the Affiliate Portal service from a login Parameters: Name Type Description id SalesforceId Contact id. match /[\\w\\d]{15,17}/ Source: controllers/facilitators/facilitators.controller.js, line 236 Returns: Reponse body is result of unmap Type Promise.&lt;Response&gt; update(body, id) PUT: /facilitators/:id Calls FacilitatorsService#update to update a Facilitator. If body contains Email or password the associated auth is also updated. Parameters: Name Type Description body any Required fields { ['Id'], oneof: ['FirstName', 'LastName', 'Email', 'password', 'Biography', etc..] } id SalesforceId Contact id. match /[\\w\\d]{15,17}/ Source: controllers/facilitators/facilitators.controller.js, line 168 Returns: Response body is status of updates and resulting SF Operation Type Promise.&lt;Response&gt; × Search results Close "},"FacilitatorsService.html":{"id":"FacilitatorsService.html","title":"Class: FacilitatorsService","body":" Shingo Affiliate Portal Classes AffiliatesControllerAffiliatesServiceAuthControllerAuthServiceBaseControllerCacheServiceFacilitatorsControllerFacilitatorsServiceSalesforceServiceUserServiceWorkshopsControllerWorkshopsService Class: FacilitatorsService FacilitatorsService new FacilitatorsService() A service to provide functions for working with Facilitators Source: components/facilitators/facilitators.component.js, line 23 Methods changeRole(extId, roleId) Change a Facilitator's role to the role specified by roleId. If a role exists that belongs to the Affiliate Portal, it is removed first Parameters: Name Type Description extId string Facilitator's Contact Id roleId any Id of the role to change to Source: components/facilitators/facilitators.component.js, line 379 Returns: Type Promise.&lt;boolean&gt; create(user) Creates a new Contact of record type 'Affiliate Instructor' in Salesforce and addes a user to the Shingo Auth api. The user create for the Auth API will be assigned the role of roleId (defaults to 'Facilitator'). Returns a response like: { &quot;jwt&quot;: string, &quot;id:&quot; number } Parameters: Name Type Description user any User to create Source: components/facilitators/facilitators.component.js, line 201 Returns: Type Promise.&lt;any&gt; createNewAuth(email, password, roleId, extId) Uses the Shingo Auth API to create a new login Parameters: Name Type Description email string password string roleId number extId string Salesforce Id of the associated contact Source: components/facilitators/facilitators.component.js, line 233 Returns: Type Promise.&lt;any&gt; delete(id) Deletes a facilitator. Returns the following: { &quot;id&quot;: SalesforceId, &quot;success&quot;: boolean, &quot;errors&quot;: [] } Parameters: Name Type Description id string Salesforce Id of the Contact to delete Source: components/facilitators/facilitators.component.js, line 325 Returns: Type Promise.&lt;any&gt; deleteAuth(extId) Delete a login from the Shingo Auth API Parameters: Name Type Description extId string Facilitator's Contact Id Source: components/facilitators/facilitators.component.js, line 343 Returns: Type Promise.&lt;boolean&gt; describe( [refresh]) Uses the Salesforce REST API to describe the Contact object. See the Salesforce documentation for more about 'describe' Parameters: Name Type Argument Default Description refresh boolean &lt;optional&gt; false Force the refresh of the cache Source: components/facilitators/facilitators.component.js, line 101 Returns: Type Promise.&lt;any&gt; get(id) Get the facilitator with the id passed at the parameter :id. The following fields are returned: [ TODO: Add fields that are returned ] Parameters: Name Type Description id string Salesforce ID for a Contact Source: components/facilitators/facilitators.component.js, line 178 Returns: Type Promise.&lt;any&gt; getAll(user [, refresh] [, affiliate]) Get all facilitators for the affiliate specified. All if affiliate === ''. The queried fields from Salesforce are as follows: [ &quot;Id&quot;, &quot;FirstName&quot;, &quot;LastName&quot;, &quot;Email&quot;, &quot;Title&quot;, &quot;Account.Id&quot;, &quot;Account.Name&quot;, &quot;Facilitator_For__r.Id&quot;, &quot;Facilitator_For__r.Name&quot;, &quot;Photograph__c&quot;, &quot;Biography__c&quot; ] Parameters: Name Type Argument Default Description user User Requires user.permissions[] and user.roles[].permissions[] refresh boolean &lt;optional&gt; false Force the refresh of the cache affiliate string &lt;optional&gt; SF Id of the affiliate to get facilitators for (or '' to get all facilitators) Source: components/facilitators/facilitators.component.js, line 57 Returns: Type Promise.&lt;Array.&lt;any&gt;&gt; mapCurrentAuth(userEmail, roleId, extId) Uses the Shingo Auth API to map a Salesforce contact to a current login Parameters: Name Type Description userEmail string roleId number extId string Salesforce Id of the associated contact Source: components/facilitators/facilitators.component.js, line 249 Returns: Type Promise.&lt;any&gt; search(search, retrieve [, affiliate] [, isAfMan] [, refresh]) Executes a SOSL query to search for text on Contacts of record type Affiliate Instructor Salesforce. Example response body: [ { &quot;Id&quot;: &quot;003g000001VvwEZAAZ&quot;, &quot;Name&quot;: &quot;Test One&quot;, &quot;Email&quot;: &quot;testone@example.com&quot; }, { &quot;Id&quot;: &quot;003g000001VvwEZABA&quot;, &quot;Name&quot;: &quot;Test Two&quot;, &quot;Email&quot;: &quot;testtwo@example.com&quot; }, { &quot;Id&quot;: &quot;003g000001VvwEZABB&quot;, &quot;Name&quot;: &quot;Test Three&quot;, &quot;Email&quot;: &quot;testthree@example.com&quot; }, ] Parameters: Name Type Argument Default Description search Header Header 'x-search'. SOSL search expression (i.e. 'Test'). retrieve Header Header 'x-retrieve'. A comma seperated list of the Contact fields to retrieve (i.e. 'Id, Name, Email') affiliate string &lt;optional&gt; '' The SF Id to filter results for (or '' for no filter) isAfMan boolean &lt;optional&gt; false Is request coming from an Affiliate Manager refresh boolean &lt;optional&gt; false Force the refresh of the cache Source: components/facilitators/facilitators.component.js, line 142 Returns: Type Promise.&lt;any&gt; unmapAuth(extId) Remove the Affiliate Portal as service for a login Parameters: Name Type Description extId string Facilitator's Contact Id Source: components/facilitators/facilitators.component.js, line 356 Returns: Type Promise.&lt;boolean&gt; update(user) Updates a facilitator's fields. Returns the following: { &quot;record&quot;: { &quot;id&quot;: SalesforceId, &quot;success&quot;: boolean, &quot;errors&quot;: [] }, &quot;salesforce&quot;: boolean, &quot;auth&quot;: boolean } Parameters: Name Type Description user any The facilitator's fields to update Source: components/facilitators/facilitators.component.js, line 277 Returns: Type Promise.&lt;any&gt; updateAuth(user, extId) Update the associated login of a facilitator Parameters: Name Type Description user any Facilitator's fields to update extId any Facilitator's Contact ID Source: components/facilitators/facilitators.component.js, line 299 Returns: Type Promise.&lt;boolean&gt; × Search results Close "},"SalesforceService.html":{"id":"SalesforceService.html","title":"Class: SalesforceService","body":" Shingo Affiliate Portal Classes AffiliatesControllerAffiliatesServiceAuthControllerAuthServiceBaseControllerCacheServiceFacilitatorsControllerFacilitatorsServiceSalesforceServiceUserServiceWorkshopsControllerWorkshopsService Class: SalesforceService SalesforceService new SalesforceService() A service to abastract the Shingo SF Microservice client Source: components/salesforce/salesforce.component.js, line 25 Methods &lt;static&gt; parseRPCErrorMeta(error) Utility method to assist in parsing gRPC error metadata. Returns a JSON object from the parsed error data. If no JSON object can be parsed, the method attempts to return the 'error-bin' from the meta-data as a string. If that fails the method returns the error passed to it. Parameters: Name Type Description error gRPCError The error to be parsed Source: components/salesforce/salesforce.component.js, line 144 Returns: The parsed error, 'error-bin'.toString(), or passed in error Type object create(data) Async wrapper for the Shingo SF Microservice create call Parameters: Name Type Description data SFRecordData See SFRecordData Source: components/salesforce/salesforce.component.js, line 78 Returns: See SFSuccessObject Type Promise.&lt;Array.&lt;SFSuccessObject&gt;&gt; delete(data) Async wrapper for the Shingo SF Microservice delete call Parameters: Name Type Description data SFIdData See SFIdData Source: components/salesforce/salesforce.component.js, line 104 Returns: See SFSuccessObject Type Promise.&lt;Array.&lt;SFSuccessObject&gt;&gt; describe(object) Async wrapper for the Shingo SF Microservice describe call Parameters: Name Type Description object string SF Object to describe Source: components/salesforce/salesforce.component.js, line 117 Returns: See {@linkhttps://developer.salesforce.com/docs/atlas.en-us.api_rest.meta/api_rest/dome_sobject_describe.htm|Salesforce Docs} Type Promise.&lt;object&gt; query(query) Async wrapper for the Shingo SF Microservice query call Parameters: Name Type Description query SFQueryObject See SFQueryObject Source: components/salesforce/salesforce.component.js, line 52 Returns: See SFQueryResponse Type Promise.&lt;SFQueryResponse&gt; retrieve(data) Async wrapper for the Shingo SF Microservice retrieve call Parameters: Name Type Description data SFIdData See SFIdData Source: components/salesforce/salesforce.component.js, line 65 Returns: Type Promise.&lt;object&gt; search(data) Async wrapper for the Shingo SF Microservice search call Parameters: Name Type Description data SFSearchData See SFSearchData Source: components/salesforce/salesforce.component.js, line 130 Returns: Array of workshops Type Promise.&lt;SFSearchResults&gt; update(data) Async wrapper for the Shingo SF Microservice update call Parameters: Name Type Description data SFRecordData See SFRecordData Source: components/salesforce/salesforce.component.js, line 91 Returns: See SFSuccessObject Type Promise.&lt;Array.&lt;SFSuccessObject&gt;&gt; × Search results Close "},"UserService.html":{"id":"UserService.html","title":"Class: UserService","body":" Shingo Affiliate Portal Classes AffiliatesControllerAffiliatesServiceAuthControllerAuthServiceBaseControllerCacheServiceFacilitatorsControllerFacilitatorsServiceSalesforceServiceUserServiceWorkshopsControllerWorkshopsService Class: UserService UserService new UserService() Provide methods for working with users Source: components/user/user.component.js, line 10 Methods getWorkshopIds(user) Parse out the workshops that a user has permissions for Parameters: Name Type Description user any Requires user.permissions[] and user.roles[].permissions[] Source: components/user/user.component.js, line 24 Returns: Type Array.&lt;string&gt; × Search results Close "},"WorkshopsController.html":{"id":"WorkshopsController.html","title":"Class: WorkshopsController","body":" Shingo Affiliate Portal Classes AffiliatesControllerAffiliatesServiceAuthControllerAuthServiceBaseControllerCacheServiceFacilitatorsControllerFacilitatorsServiceSalesforceServiceUserServiceWorkshopsControllerWorkshopsService Class: WorkshopsController WorkshopsController new WorkshopsController() Controller of the REST API logic for Workshops Source: controllers/workshops/workshops.controller.js, line 28 Extends BaseController Methods create(body, session) POST: /workshops Calls WorkshopsService#create to create a new workshop in Salesforce and permissions for the workshop in the Shingo Auth API Parameters: Name Type Description body Body Required fields [ &quot;Name&quot;, &quot;Organizing_Affiliate__c&quot;, &quot;Start_Date__c&quot;, &quot;End_Date__c&quot;, &quot;Host_Site__c&quot;, &quot;Event_Country__c&quot;, &quot;Event_City__c&quot;, &quot;facilitators&quot; ] session Session Accesses the affiliate id from the session to compare to the Organizaing_Affiliate__c on the body Source: controllers/workshops/workshops.controller.js, line 160 Returns: Response is a JSON Object from the resulting Salesforce operation Type Promise.&lt;Response&gt; delete(id) DELETE: /workshops/:id Calls WorkshopsService#delete to delete the workshop given by :id Parameters: Name Type Description id SalesforceId Workshop__c id. match /a[\\w\\d]{14,17}/ Source: controllers/workshops/workshops.controller.js, line 276 Returns: Response is a JSON Object from the resulting Salesforce operation Type Promise.&lt;Response&gt; describe( [refresh]) GET: /workshops/describe Calls WorkshopsService#describe to describe Workshop__c Parameters: Name Type Argument Default Description refresh Header &lt;optional&gt; 'false' Header 'x-force-refresh'; Expected values [ 'true', 'false' ]; Forces cache refresh Source: controllers/workshops/workshops.controller.js, line 75 Returns: Response body is a JSON object with the describe result Type Promise.&lt;Response&gt; facilitators(id) GET: /workshops/:id/facilitators Calls WorkshopsService#facilitators to get all associated facilitators for a workshop Parameters: Name Type Description id SalesforceId Workshop__cid. match /a[\\w\\d]{14,17}/ Source: controllers/workshops/workshops.controller.js, line 138 Returns: Response is a JSON Array of Contact objects Type Promise.&lt;Response&gt; &lt;protected&gt; handleError(res, message, error [, errorCode]) A helper function to return an error response to the client. Parameters: Name Type Argument Default Description res Response The express response from the calling route message string Log message error * An error object to be logged and returned as JSON errorCode HttpStatus &lt;optional&gt; HttpStatus.INTERNAL_SERVER_ERROR HttpStatus CODE Inherited From: BaseController#handleError Source: controllers/base.controller.js, line 35 Returns: Response body is a JSON object with the error read(id) GET: /workshops/:id Calls WorkshopsService#get to retrieve a specific workshop Parameters: Name Type Description id SalesforceId Workshop__c id. match /a[\\w\\d]{14,17}/ Source: controllers/workshops/workshops.controller.js, line 117 Returns: Response body is a JSON object of type {returned fields} Type Promise.&lt;Response&gt; readAll(session, isPublicQ, isPublicH [, refresh]) GET: /workshops Calls WorkshopsService#getAll to get an array of Workshops Parameters: Name Type Argument Default Description session Session Session contains the current user. The function uses the permissions on this object to query Salesforce for the workshops. isPublicQ any Query parameter 'isPublic'; Expected values [ 'true', 'false' ]; Alias headers['x-force-refesh']; Returns public workshops isPublicH any Header 'x-is-public'; Expected values [ 'true', 'false' ]; Alias query['isPublic']; Returns public workshops refresh Header &lt;optional&gt; 'false' Header 'x-force-refresh'; Expected values [ 'true', 'false' ]; Forces cache refresh Source: controllers/workshops/workshops.controller.js, line 52 Returns: Response body contains a JSON array of Workshops Type Promise.&lt;Response&gt; search(search, retrieve [, refresh]) GET: /workshops/search Calls WorkshopsService#search. Returns an array of workshops that match search criteria Parameters: Name Type Argument Default Description search Header Header 'x-search'. SOSL search expression (i.e. 'Discover Test'). retrieve Header Header 'x-retrieve'. A comma seperated list of the Workshop__c fields to retrieve (i.e. 'Id, Name, Start_Date__c') refresh Header &lt;optional&gt; 'false' Header 'x-force-refresh'; Expected values [ 'true', 'false' ]; Forces cache refresh Source: controllers/workshops/workshops.controller.js, line 96 Returns: Response body is a JSON Array of workshops Type Promise.&lt;Response&gt; update(body, session, id) PUT: /workshops/:id Calls WorkshopsService#update to update a workshop's fields. This function also updates facilitator associations and permissions Parameters: Name Type Description body Body Required fields [ &quot;Id&quot;, &quot;Organizing_Affiliate__c&quot; ] session Session Accesses the affiliate id from the session to compare to the Organizaing_Affiliate__c on the body id SalesforceId Workshop__c id. match /a[\\w\\d]{14,17}/ Source: controllers/workshops/workshops.controller.js, line 193 Returns: Response is a JSON Object from the resulting Salesforce operation Type Promise.&lt;Response&gt; × Search results Close "},"WorkshopsService.html":{"id":"WorkshopsService.html","title":"Class: WorkshopsService","body":" Shingo Affiliate Portal Classes AffiliatesControllerAffiliatesServiceAuthControllerAuthServiceBaseControllerCacheServiceFacilitatorsControllerFacilitatorsServiceSalesforceServiceUserServiceWorkshopsControllerWorkshopsService Class: WorkshopsService WorkshopsService new WorkshopsService() A service to provide functions for working with Workshops Source: components/workshops/workshops.component.js, line 23 Methods create(workshop) Creates a new workshop in Salesforce and creates permissions for the workshop in the Shingo Auth API. Returns the following: { &quot;id&quot;: SalesforceId, &quot;success&quot;: boolean, &quot;errors&quot;: [] } Parameters: Name Type Description workshop Workshop The workshop to be created. Requires [ 'Name', 'Start_Date__c', 'End_Date__c', 'Organizing_Affiliate__c' ] Source: components/workshops/workshops.component.js, line 256 Returns: Type Promise.&lt;any&gt; delete(id) Deletes the workshop given by :id in Salesforce and removes the permission in the Auth API. Returns the following: { &quot;id&quot;: SalesforceId, &quot;success&quot;: boolean, &quot;errors&quot;: [] } Parameters: Name Type Description id string Source: components/workshops/workshops.component.js, line 324 Returns: Type Promise.&lt;any&gt; describe( [refresh]) Uses the Salesforce REST API to describe the Workshop__c object. See the Salesforce documentation for more about 'describe'. Parameters: Name Type Argument Default Description refresh boolean &lt;optional&gt; false Force the refresh of the cache Source: components/workshops/workshops.component.js, line 151 Returns: Type Promise.&lt;any&gt; facilitators(id) Get the associated instructors for the workshop with id given in the param :id. Queried fields are as follows: [ &quot;Instructor__r.FirstName&quot;, &quot;Instructor__r.LastName&quot;, &quot;Instructor__r.Email&quot;, &quot;Instructor__r.Title&quot; ] Parameters: Name Type Description id string A Salesforce ID corresponding to a Workshop__c record Source: components/workshops/workshops.component.js, line 225 Returns: Type Promise.&lt;Array.&lt;object&gt;&gt; get(id) Get a specific workshop by Salesforce ID. Retrieves all fields of the Workshop__c object. Specifically: [ &quot;Id&quot;, &quot;IsDeleted&quot; , &quot;Name&quot;, &quot;CreatedDate&quot;, &quot;CreatedById&quot;, &quot;LastModifiedDate&quot;, &quot;LastModifiedById&quot;, &quot;SystemModstamp&quot;, &quot;LastViewedDate&quot;, &quot;LastReferencedDate&quot;, &quot;Billing_Contact__c&quot;, &quot;Course_Manager__c&quot;, &quot;End_Date__c&quot;, &quot;Event_City__c&quot;, &quot;Event_Country__c&quot;, &quot;Organizing_Affiliate__c&quot;, &quot;Public__c&quot;, &quot;Registration_Website__c&quot;, &quot;Start_Date__c&quot;, &quot;Status__c&quot;, &quot;Workshop_Type__c&quot;, &quot;Host_Site__c&quot;, &quot;Language__c&quot;, ] Parameters: Name Type Description id string A Salesforce ID corresponding to a Workshop__c record Source: components/workshops/workshops.component.js, line 136 Returns: Type Promise.&lt;Workshop&gt; getAll( [isPublic] [, refresh] [, user]) Get all workshops that the current session's user has permissions for (or all publicly listed workshps). The function assembles a list of workshop ids form the users permissions to query Salesforce. The queried fields from Salesforce are as follows: [ &quot;Id&quot;, &quot;Name&quot;, &quot;Start_Date__c&quot;, &quot;End_Date__c&quot;, &quot;Course_Manager__c&quot;, &quot;Billing_Contact__c&quot;, &quot;Event_City__c&quot;, &quot;Event_Country__c&quot;, &quot;Organizing_Affiliate__c&quot;, &quot;Public__c&quot;, &quot;Registration_Website__c&quot;, &quot;Status__c&quot;, &quot;Host_Site__c&quot;, &quot;Workshop_Type__c&quot;, &quot;Language__c&quot; ] The query is ordered by 'Start_Date__c'. Parameters: Name Type Argument Default Description isPublic boolean &lt;optional&gt; false Get Only public workshops (skips permission check) refresh boolean &lt;optional&gt; false Force the refresh of the cache user any &lt;optional&gt; The user to filter permissions for (isPublic === false); user needs permissions[] and roles[].permissions[] Source: components/workshops/workshops.component.js, line 63 Returns: Type Promise.&lt;Array.&lt;Workshop&gt;&gt; search(search, retrieve [, refresh]) Executes a SOSL query to search for text on workshop records in Salesforce. Example response body: [ { &quot;Id&quot;: &quot;a1Sg0000001jXbgEAE&quot;, &quot;Name&quot;: &quot;Test Workshop 10 (Updated)&quot;, &quot;Start_Date__c&quot;: &quot;2017-07-12&quot; }, { &quot;Id&quot;: &quot;a1Sg0000001jXWgEAM&quot;, &quot;Name&quot;: &quot;Test Workshop 9 (Updated)&quot;, &quot;Start_Date__c&quot;: &quot;2017-07-11&quot; }, { &quot;Id&quot;: &quot;a1Sg0000001jXWbEAM&quot;, &quot;Name&quot;: &quot;Test Workshop 8&quot;, &quot;Start_Date__c&quot;: &quot;2017-07-11&quot; } ] Parameters: Name Type Argument Default Description search Header SOSL search expression (i.e. 'Discover Test') retrieve Header A comma seperated list of the Workshop__c fields to retrieve (i.e. 'Id, Name, Start_Date__c') refresh Header &lt;optional&gt; 'false' Used to force the refresh of the cache Source: components/workshops/workshops.component.js, line 193 Returns: Type Promise.&lt;Array.&lt;Workshop&gt;&gt; update(workshop) Updates a workshop's fields. This function also will get the instructor associations with the given workshop to update associations and permissions. Returns the following: { &quot;id&quot;: SalesforceId, &quot;success&quot;: boolean, &quot;errors&quot;: [] } Parameters: Name Type Description workshop Workshop Source: components/workshops/workshops.component.js, line 281 Returns: Type Promise.&lt;any&gt; × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
